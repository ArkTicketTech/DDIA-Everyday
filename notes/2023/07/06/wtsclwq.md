### 多对象事务的需求

很多NoSQL都舍弃了事务的支持是，但是我们真的能够将所有的操作都用KV模型和单对象操作完成吗？

1. 外键更新
2. 更新非规范化数据（关系表）
3. 更新多个索引（二级索引）

可以发现，上述的情景还是更加适合事务模型来处理，尤其是原子性和隔离性。

### 更弱的隔离级别

可串行化的隔离级别虽然能保证每个事务的安全性，但是也会带来一定的性能损失。实际上，即使不提供隔离性保证，两个事务发生数据冲突也不是必然的，是偶发性的。

因此很多数据库在实现的时候，提供了多种隔离级别，从而能够让使用者根据自己的使用场景来决定数据库该使用哪种隔离级别。

如果不提供任何隔离性保证，会出现两大问题：

1. 脏读，也就是一个读操作有可能会读取到其他事务的中间数据，导致读到的数据和真实的最终数据不一致
   1. 如果一个事务更新多个对象，脏读会导致另一个事务，读取到的多个对象，状态并不一致，比如事务1只更新了点赞数还没更新播放量，事务2就会发现点赞数为1，播放量为0的问题
   2. 事务2读到的数据，可能会因为事务1的回滚而丢失，导致事务2读到的数据，和数据的最终状态不一致。
2. 脏写，也就是一个写操作会写入到其他事务的中间数据，导致写入的数据丢失
   - 事务1写入了一个数据还没来得及提交，事务2也写入了同一个数据，提交了，这就导致事务1以为自己的写入成功了，实则没有。

### 读未提交

该级别只提供了避免脏写的能力，也就是只加写锁，不加读锁，会出现脏读的问题

### 读已提交

同是解决脏读和脏写

<img src="https://wtsclwq.oss-cn-beijing.aliyuncs.com/ch07-fig04.png" alt="Untitled" style="zoom:50%;" />

上图就是解决脏读的例子，用户2不会看到用户1写入到一半的数据，直到用户1的事务提交。

<img src="https://wtsclwq.oss-cn-beijing.aliyuncs.com/ch07-fig05.png" alt="Untitled" style="zoom:50%;" />

上图是解决脏写的例子
