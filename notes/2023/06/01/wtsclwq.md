### 对比B-Tree和LSM-Tree

最应该知道的：B-Tree拥有更好的读性能，LSM-Tree拥有更好的写性能

|          |                                                       |                                                              |                                                              |
| -------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储引擎 | B-Tree                                                | LSM-Tree                                                     | 备注                                                         |
| 优势     | 读取更快                                              | 写入更快                                                     |                                                              |
| 写放大   | 1. 数据和 WAL  2. 更改数据时多次覆盖整个 Page         | 1. 数据和 WAL  2. Compaction                                 | SSD 不能过多擦除。因此 SSD 内部的固件中也多用日志结构来减少随机小写。 |
| 写吞吐   | 相对较低： 1. 大量随机写。                            | 相对较高： 1. 较低的写放大（取决于数据和配置） 2. 顺序写入。 3. 更为紧凑。 |                                                              |
| 压缩率   | 1. 存在较多内部碎片。                                 | 1. 更加紧凑，没有内部碎片。 2. 压缩潜力更大（共享前缀）。    | 但紧缩不及时会造成 LSM-Tree 存在很多垃圾                     |
| 后台流量 | 1. 更稳定可预测，不会受后台 compaction 突发流量影响。 | 1. 写吞吐过高，compaction 跟不上，会进一步加重读放大。 2. 由于外存总带宽有限，compaction 会影响读写吞吐。 3. 随着数据越来越多，compaction 对正常写影响越来越大。 | RocksDB 写入太过快会引起 write stall，即限制写入，以期尽快 compaction 将数据下沉。 |
| 存储放大 | 1. 有些 Page 没有用满                                 | 1. 同一个 Key 存多遍                                         |                                                              |
| 并发控制 | 1. 同一个 Key 只存在一个地方 2. 树结构容易加范围锁。  | 同一个 Key 会存多遍，一般使用 MVCC 进行控制。                |                                                              |

### 其他索引结构

#### 在索引中存储value

> 索引中的键是查询搜索的对象, 而值则可以是以下两类之一: 它可能是上述的实际行(文档, 顶点), 也可以是对其他地方存储的行的引用。

第一种情况中，被称为聚集索引，比如innodb，表的主键始终是聚集索引, 二级索引引用主键

第二种情况中，通常采用的是heap file的文件组织方式，主键索引和二级索引都存储heap file中的位置

**当更新值而不更改键时**, 堆文件方法会非常高效: 

- 只要新值的字节数不大于旧值, 记录就可以直接覆盖。 
- 如果新值较大,则情况会更复杂, 它可能需要移动数据以得到 一个足够大空间的新位置。 在这种情况下, 所有索引都需要更新以指向记录的新的堆位四, 或者在旧堆位置保留一个间接指针

#### 多列索引

现实生活中，多个字段联合查询更为常见。比如查询某个用户周边一定范围内的商户，需要经度和纬度二维查询。

```sql
SELECT * FROM restaurants WHERE latitude > 51.4946 AND latitude < 51.5079
                            AND longitude > -0.1162 AND longitude < -0.1004;
```

可以：

1. 将二维编码为一维，然后按普通索引存储。
2. 使用特殊数据结构，如 R 树。

#### 全文索引和模糊索引

前述索引只提供全字段的精确匹配，而不提供类似搜索引擎的功能。比如，按字符串中包含的单词查询，针对笔误的单词查询。

在工程中常用 [Apace Lucene](https://lucene.apache.org/) 库，和其包装出来的服务：[Elasticsearch](https://www.elastic.co/cn/)。他也使用类似 LSM-tree 的日志存储结构，但其索引是一个有限状态自动机，在行为上类似 Trie 树。
