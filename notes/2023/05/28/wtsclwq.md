#### 优化

1. 文件格式：普通的CSV格式信息密度不足，可以使用length + data的二进制形式组织文件。
2. 删除记录：这种apend-only的方式对删除的支持不够，但是可以通过添加墓碑的方式来标记删除，等到压缩时删除
3. 宕机恢复：hash map在内存中，重启后会丢失，最简单的方式是每次重启遍历日志文件重建hash map。更高效的方法是在运行时存储快照，每次重启后加载快照即可。
4. **记录写坏、少写**：系统任何时候都有可能宕机，由此会造成记录写坏、少写。为了识别错误记录，我们需要增加一些校验字段，以识别并跳过这种数据。为了跳过写了部分的数据，还要用一些特殊字符来标识记录间的边界。

5. 并发控制：添加读写锁，对于压缩来说也可以并发，因为压缩后的内容是追加在新文件后的。

#### 日志结构的优点：

1. **以顺序写代替随机写**。对于磁盘和 SSD，顺序写都要比随机写快几个数量级。
2. **简易的并发控制**。由于大部分的文件都是**不可变（immutable）** 的，因此更容易做并发读取和紧缩。也不用担心原地更新会造成新老数据交替。
3. **更少的内部碎片**。每次紧缩会将垃圾完全挤出。但是原地更新就会在 page 中留下一些不可用空间。

#### HashMap的局限

1. **所有 Key 必须放内存**。一旦 Key 的数据量超过内存大小，这种方案便不再 work。当然可以设计基于磁盘的哈希表，但那又会带来大量的随机写。
2. **不支持范围查询**。由于 key 是无序的，要进行范围查询必须全表扫描。

#### SSTable和LSM-Tree

对于 KV 数据，前面的 BitCask 存储结构是：

1. 外存上日志片段
2. 内存中的哈希表

其中外存上的数据是简单追加写而形成的，查询时按照最新的为准，并没有按照某个字段有序。

但实际中经常要求kv按照某种顺序排列，以支持范围查询，如果想要让kv按照key进行排序，就需要引入SSTable。

