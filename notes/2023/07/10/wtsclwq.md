### 防止更新丢失

读已提交和快照隔离都是站在只读事务的角度，有并发写入时，那些数据是可见的。解决的是读事务和写事务的冲突。

在写写冲突方面，**更新丢失**问题非常常见。

如下情况：两个事务的操作序列都是`读-修改-写入`，也就是说后面的写入要依靠最开始读的结果，那么如果当前操作的对象，在这期间被其他事务修改，后续的写入结果就有可能丢失。

#### 解决方法

1. 原子写：有些数据库提供原子的（**针对单个对象的**）read-modify-write 

   实现方式：读去对象之后获取互斥锁，写入之后再释放

2. 显示锁：在SQL语句中指定锁:	`select xx where xx for update;`

3. 乐观方式：自动检测更新丢失然后重试

4. CAS：仅当发现内容没有被修改时，才写会修改后的内容。

5. 多副本数据库中的冲突解决更加复杂，要区分多主、无主、单主

### 写偏序和幻读

写偏序发生多个事务，尝试更新不同对象时。而脏读和更新丢失主要是因为多个事务尝试更新同一个对象。

<img src="https://ddia.qtmuniao.com/img/ch07-fig08.png" style="zoom:33%;" />

解释一下上图：A和B同时值班，医院需要保证任何时刻必须有一个人在值班。但是A和B同时请假，请假的流程：查询当前医生人数，如果>=2就将自己的oncall设置为false，表示不再接受请求。

然而在两人发起请求的时刻，读取到的当前人数都是2，因此都将自己的oncall设置为false，然后一起走了，最后值班室没人了。

没有违反快照隔离级别，因为二者访问的数据甚至都不一样。
