# 第五章 数据复制

本章讨论的是完全复制，也就是数据量足够小，集群中每台机器都存着所有数据。

### 为什么要复制多份数据？

1. 多地的用户能够以近似的速度访问数据 -> 减少延迟
2. 提供容错能力，一个挂了其他顶上 -> 可用性
3. 可以伸缩可提供服务的节点数量 -> 提高吞吐量 

### Leader和Follower分别是什么？

- Leader：又称为primary/master，用来接受用户的写入请求
- Follower：又称为secondaries/read replicass，用来存储副本，跟着Leader更新，有些算法中也可以处理读请求，对于写请求一律转发给Leader
- 在客户端眼中没有这么多角色，他只是在向某一个服务读/写，具体的请求转发、处理、响应都由集群来做

### ![](https://wtsclwq.oss-cn-beijing.aliyuncs.com/image-20230612104158252.png)

### 同步复制和异步复制

同步写入和移步写入比较好理解，在单体DB里这是一个可配置项，用来决定什么时候刷盘。

在分布式场景下就转变成了Leader和Follower的写入是否是同步的，Leader是否应该等待所有Follower都写入了再响应客户端呢？

<img src="https://wtsclwq.oss-cn-beijing.aliyuncs.com/image-20230612104712683.png" alt="image-20230612104712683" style="zoom:50%;" />

上图中演示了两种做法， 对于Follower1来说，Leader一直等待它的响应（写入成功），接收到Follower的相应之后在响应客户端。而对于Follower2，Leader就不care它是否响应，只是把消息丢给Follower，不会等待Follower的响应。

当然在Follower1、2和Leader的内部，刷盘到底是同步还是异步也是一个可配置项。

> 同步复制的优点是，从库能保证有与主库一致的最新数据副本
>
> 缺点是，如果同步从库没有响应，主库就无法处理写入操作

异步复制的优缺点差不多相反

> **半同步**：其中 **一个** 从库是同步的，而其他的从库则是异步的。

在大多数系统中，都采用了异步复制。
