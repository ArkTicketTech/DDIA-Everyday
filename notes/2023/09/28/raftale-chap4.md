双向兼容：

1. 向后兼容：新的代码可以读取由旧代码写入的数据
2. 向前兼容：旧的代码可以读取新的代码写入的数据



向后兼容比较容易实现





本章将介绍以下格式：JSON、XML、protocal buffers、Thrift、Avro。

如果使用这些格式进行数据存储和通信：web中，表述性状态状态（REST）和远程过程调用（RPC）、消息传递系统（Actor和消息队列）





## 编码数据的格式



1. 在内存中，数据保存在对象、结构体、列表、数组、hash、树中，这些数据针对CPU的高效访问和操作进行了优化
2. 如果要将数据写入文件，或者通过网络发送，就必须将其编码（encode）为某种自包含的字节序列，例如JSON。由于每个进程都有自己独立的地址空间，一个进程中的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数据结构完全不同。



所以，需要在两种表示之间进行某种类型的翻译。从内存中到字节序列的转换称为编码，也称为反序列化；反过来叫做解码和序列化。



### 语言特定的格式

许多编程语言都内建了将内存对象编码为字节序列的支持，如Java的`java.io.Serializable`，和第三方的`Kryo for Java`。

这些编码库非常方便，可以使用很少的额外代码实现内存对象的保存和恢复，但它们有一些问题：

1. 与语言深度绑定；
2. 解码需要实例化任何类的能力，攻击者可以让应用程序解码任意的字节序列，他们就能实例化任意的类，这可以让他们远程执行一些危险代码；
3. 兼容问题
4. 效率问题



### JSON、XML和二进制变体

JSON 和 XML 可以被多种语言读写。

JSON 和 XML、CSV属于文本格式，具有人类可读性。

但他们也存在一些问题：

1. 数字编码模糊，JSON不区分整数和浮点数，XML无法区分数字和数字组成的字符串；
2. JSON和XML支持Unicode，但他们不支持二进制数据（如base64）





#### 二进制编码

数据达到TB，数据格式就会产生巨大的影响。



JSON比XML简洁，但是太占用空间。

```json
{
    "userName": "Martin",
    "favoriteNumber": 1337,
    "interests": ["daydreaming", "hacking"]
}
```



![img](https://cdn.nlark.com/yuque/0/2023/png/32473878/1695893278191-5ea94c97-6381-4a30-9706-6c045693a5e7.png)



### Thrift与Protocol Buffers





## 数据流的类型

### 数据库中的数据流

在数据库中，写入数据库的过程对数据进行编码，从数据库读取的过程对数据进行解码。

数据库的向后兼容和向前兼容是必要的。



### 服务中的数据流：REST和RPC



SOA：面向服务的体系结构（Service-oriented architecture），也就是微服务架构

微服务架构应用于组织结构

#### web服务

当服务使用HTTP作为底层通信协议时，可称为web服务。

有两种流行的web服务方法：

1. REST：不是一个协议，而是一个基于HTTP原则的设计哲学
2. SOAP：用于制作网络API请求的基于XML协议，较复杂，使用较少



#### RPC的问题

RPC是一种远程调用的思想。



RPC试图向远程网络服务发送请求。

1. 本地函数调用可预测，网络请求不可预测
2. 网络请求有超时的风险
3. 网络请求重试需要保持幂等性
4. 网络延迟可变
5. 网络请求需要将对象编码为字节，大对象会有性能问题



### 消息传递中的数据流



与直接RPC相比，消息队列有几个优点：

1. 缓冲
2. 可以自动将消息重新发送到已经崩溃的进程，防止消息丢失
3. 避免发件人知道收件人的ip地址和端口号
4. 将一条消息发送给多个收件人
5. 解耦



消息传递是单向的，通常不期望收到消息的恢复，天然异步的



Actor 模型是单个进程中并发的编程模型。
