### 如何处理并发写

在所有的复制方法中，我们都看到了一个共同的问题，即所有的复制方法都无法完全解决并发写入问题。然而，在并发写入又是一个很常见的问题。

并发写入可以通过合并结果或其他首次/最后一次写入优胜等方法来解决。并发写入的另一个问题是写入到达的顺序。这可能是由于网络延迟或节点无响应导致的。不能直接处理这些操作，因为这可能导致数据丢失或两个节点上的不一致结果。

**最后写入胜出（LWW）**

这是一种非常简单的方法，其中我们丢弃并发写入，并根据写入先后时间戳的不同选择最新的值。如果某个节点收到的写入的时间戳小于它已记录的资源时间戳，它将简单地丢弃该请求。如果时间戳大于节点自身的时间戳，则使用较新的值覆盖现有资源。

Cassandra目前支持LWW作为解决并发写入冲突的方法。Riak也使用它作为默认的冲突解决机制，尽管它还有使用向量时钟的选项。

**先于关系（Happens-before relationship）**

建立先于关系可以确保没有数据丢失，并使客户端更新自身以获取任何同时更新的值。

1. 写操作的"happens before"关系：如果一个写操作被提交并成功地被一个副本接受并保存，那么这个写操作"happens before"任何后续读操作或写操作。这意味着之后的读操作或写操作将能够看到先前提交的写操作的结果。
2. 读操作的"happens before"关系：如果一个读操作从一个副本获取数据，并成功返回给应用程序，那么这个读操作"happens before"任何后续的读操作或写操作。这确保后续的读操作或写操作将能够看到先前成功返回的读操作所读取的数据。

通过维护适当的"happens before"关系，无主复制系统可以确保操作的顺序性和一致性。这种关系可以通过使用时间戳、向量时钟或其他顺序标记技术来实现。

需要注意的是，"happens before"并不是全局的时间顺序，而是在每个副本或节点上的局部顺序。不同的副本可能会有不同的"happens before"关系，这取决于副本所接收和处理的操作的顺序。

当客户端进行写入时，必须包括上次读取的先前版本号，并合并先前读取到的所有值。
当服务器接收到带有版本号的写入时，可以覆盖所有版本号及以下的值，但它会保留版本号高于请求版本号的所有值。
上述机制是针对单节点系统定义的。为了满足多节点系统的用例，我们需要为每个节点存储一个版本号，以及与键关联的版本号。在多节点系统中处理先于关系的机制也称为版本向量。

**合并并发写入的值**

如果应用程序不能容忍任何数据丢失，应遵循此方法。作为此方法的一部分，如果多个请求更新同一资源，则客户端还需要负责处理冲突的值。这可以通过在应用程序层面选择一个值（基于版本号/时间戳或其他因素）来完成。当我们删除一个资源时，合并结果中不添加该值无法正确工作。因为两个并发请求可以同时更新和删除一个资源。但是删除操作不能通过不将该值添加到合并结果来表示。它需要用一个代表删除的墓碑来标记。墓碑可以简单地是在合并结果的末尾添加“_delete”。
