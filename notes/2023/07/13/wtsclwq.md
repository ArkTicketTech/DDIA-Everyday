总结起来就是两个事务读取相同的对象，但是会写入不同的对象，会导致写偏序，根本原因是事务的原子性在多个对象上得不到保证。

解决方法：

除了使用可串行化的事务隔离级别，也可以使用显示锁，自己决定上锁的顺序。

上面的例子直接原因就是幻读，**一个事务中的写入改变另一个事务的搜索查询的结果**

### 可串行化

之前的级别都会有各自的问题，最简单粗暴的办法是让事务一个一个执行，完全舍弃事务的并发处理，更好的办法是实现一种能够让并发执行的事务的最终结果和串行化执行的结果一样。

实现的思路有：

1. 2PL
2. MVCC（可串行化级别）

#### 2PL

1. 读与写的阻塞通过加锁来实现
2. 分为读锁和写锁（S和X）

运行的规则

1. 申请阶段：
2. 读操作加读锁，读锁可共享
3. 写操作加写锁，写锁独占
4. 先读再写的事务会有锁升级机制，其实就是尝试获取写锁
5. 释放阶段：
6. 拿到锁之后，一直持有到事务结束之前的释放阶段

死锁：

A事务先得到第一行的读锁，B事务先得到第二行的读锁，然后A去申请第二行的写锁，B去申请第一行的写锁，就发生了死锁

死锁有两种处理方式

1. 死锁检测，后台运行一个线程检测事务之间的依赖关系有没有环
2. 死锁避免，在申请锁之前就去检查这一次申请锁的操作会不会产生死锁，如果会就等待或者终止

