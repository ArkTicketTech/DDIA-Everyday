#### 原子性
原子性在计算机的不同领域中的定义有细微的差别。
在多线程编程领域，一个原子操作就代表着其他线程看不到该操作的中间结果，比如C++中的`atomic`库，那么对于被操作数来说，他只能处于操作之前或者操作之后的状态。
在ACID中，原子性更多的偏向于多线程领域中后面那个特性，也就是一个操作的要么会执行成功，要么失败，不会让被操作的对象最终处在操作的中间状态。
当然这是对于用户来说的，因为一个数据库查询，并不是瞬时完成的，在执行过程中如果发生崩溃，对于当时的数据库来说，内部的状态就是处在中间状态的，但是事务的原子性保证了当数据库重启后，会将该对象的状态恢复到执行之前，让用户看起来，这个操作就像没有执行过一样。
> 因此ACID中原子性所定义的特征是：在出错时中止事务， 并将部分完成的写入全部丢弃。 也许可中止性比原子性更为准确， 不过我们还是沿用原子性这个惯用术语。

另外，类比多线程操作中，其他线程能否观察到被操作对象的中间状态。数据库多个事务同时执行的时候，能否看见其他事务执行的中间状态，是由**隔离性**来保证的。
#### 一致性
一致性在不同场景下有不同的含义。
在多副本中，有最终一致性的概念。
在动态分区中，有一致性哈希。
在CAP理论中，一致性==可线性化
在ACID中，一致性指数据库处于应用程序（用户）所期待的“预期状态”
因此一致性在数据库中其实更多的是和用户的需求挂钩，比如某个操作需要保持数据库的唯一性约束、完整性约束、外键依赖约束等，并不单纯是一个技术概念。
> 这种一致性本质上要求应用层来维护状态一致（或者恒等）， 应用程序有责任正确地定义事务来保持一致性。 这不是数据库可以保证的事情： 即如果提供的数据修改违背了恒等条件， 数据库很难检测进而阻止该操作（数据库可以完成针对某些特定类型的恒等约束检查， 例如使用外键约束或唯一性约束。 但通常主要靠应用程序来定义数据的有效／无效状态， 数据库主要负责存储）。

醍醐灌顶的一句话，终于解决了我在一致性方面的疑惑。
> 字母C其实并不应该属千ACID
