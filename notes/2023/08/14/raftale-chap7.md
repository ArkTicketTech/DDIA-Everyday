可串行化
保证事务并行执行时和连续依次执行时一样的。
大多数数据库采用下面三种技术实现可串行化的隔离等级
1. 真的串行执行
2. 两阶段锁定（2PL）：MySQL
3. 可串行化快照隔离：PostgreSQL

真的串行执行
不要并发，在单线程上依次串行执行所有事务。
直到07年才变得可行，因为：
1. RAM足够便宜了，许多场景都可以将完整的活跃数据集保存在内存中；
2. OLTP事务通常很短，一般都是读多写少，长时间的分析查询通常是只读的，因此它们可以在串行执行循环之外的一致快照上运行（快照隔离）
串行执行事务的方法在VoltDB/H-Store，Redis 和 Datomic 中实现，设计用于单线程执行的系统有时可以比支持并发的系统性能更好，因为它们可以避免锁的协调开销。但是其吞吐量仅限于单个 CPU 核的吞吐量。为了充分利用单一线程，需要与传统形式的事务不同的结构

在存储过程中封装事务
多个语句打包的事务是以交互式的客户端/服务器的风格执行，一次一个语句，应用程序进行查询，读取结果，可能根据第一个查询的结果进行另一个查询。查询和结果在应用程序的节点上和数据库服务器（另一个节点）之间来回发送。
考虑到这样应用程序和数据库之间的网络通信耗费了大量的时间，或者是具有单线程事务处理的系统不允许交互式的多语句事务，取而代之，应用程序必须提前将整个事务代码作为存储过程提交给数据库。如果事务所需的所有数据都在内存中，则存储过程可以非常快地执行，而不用等待任何网络或磁盘 I/O。

其实在单线程的系统上，存储过程的吞吐量还是相当好的，但是大多数情况下，它的缺点也很严重。
1. 存储过程语言的落后，生态不好；
2. 难以维护，难调试，难以保持版本控制和部署，难以测试；
3. 一段不好的存储过程会比在应用层更麻烦。
分区
串行执行没有并发，但数据库的事务吞吐量被限制为单机单核的速度。为了伸缩至多个cpu核心和多个节点，可以对数据进行分区，为每个分区指定一个独立的cpu核，事务吞吐量就可以与cpu核数保持线性伸缩。
但是，对于需要访问多个分区的任何事务，数据库必须在触及的所有分区之间协调事务。存储过程需要跨越所有分区锁定执行，以确保整个系统的可串行性。

 由于跨分区事务具有额外的协调开销，所以它们比单分区事务慢得多。
还需要考虑二级索引需要大量的跨分区协调。

两阶段锁定
两阶段锁定（2PL，two-phase locking）
脏写的解决方案：对写入加锁。
2PL类似，但锁的要求更强。
1. 只要没有写入，就允许多个事务同时读取同一对象
2. 只要对象有写入，就需要独占访问权限；
这里的独占访问包括了 读和写，独占的含义意味着排他性，具体是：
1. 如果事务A读取了一个对象，并且事务B想要写入该对象，那么B必须等待A提交或中止才能继续；
2. 如果事务A写入了一个对象，并且事务B想要读取该对象，那么B必须等待A提交中止才能继续。

也就是说，2PL中，同一对象的读写会相互阻塞，当一个对象开始写的时候，就一定能保证此时只有当前这一个事务在操作这个对象，看起来就像是真正的串行化执行，至于读读，不串行也没关系，因为读写的相互阻塞保证了读读不会有任何副作用。
快照隔离是读不阻塞写，写不阻塞读
脏写的写锁只保证了写写相互阻塞，但涉及到读写的时候，会有前面提到的lost udpate和write skew， 而2PL则完全没有这个问题。

实现两阶段锁
读和写的阻塞是通过给数据库每个对象加锁来实现的，根据2PL的目标，锁可以处于 共享模式(share mode)和独占模式（exclusive mode)。
共享和独占的基本原则是：共享锁可以反复获取；但想要获取独占锁，就不能有其他锁的存在，一旦获取到了独占锁，其他锁将不再被允许获取（可以选择等待获取）。
保证读写相互阻塞
1. 如果某个事务想读取一个对象，需要首先获取该对象的共享锁。读读是可以共享的，所以允许多个事务同时持有获得共享锁。当有独占锁时，获取共享锁必须等待。
2. 如果某个事务想写入一个对象，需要首先获取该对象的独占锁（互斥锁），如果此时该对象还有其他锁（共享锁和独占锁），必须等待锁释放。
3. 如果某个事务要先读取，再写入某个对象，可以先获取共享锁，再升级为独占锁。升级锁的条件与直接获取独占锁的条件相同。
  a. 如果先写，后读取，独占锁会降级到共享锁吗？
4. 当某个事务获取锁之后，必须持有锁到事务结束。这也是两阶段名字的来源，第一阶段（事务执行阶段）获取锁，第二阶段（事务结束阶段）释放拥有的锁。

如果等待锁成环，就会发生死锁，2PL的死锁概率很高。数据库会自动检测事务之间的死锁，并中止一个，以便另一个继续执行。被中止的数据库不会自动执行，需要应用程序重试。

谓词锁predicate lock
写入偏差和幻读 ：一个事务的写入改变了另一个事务的搜索查询的结果。搜索查询可能是多个条件的一个范围，并不属于特定的对象，之前共享锁和独占锁都是针对的特定行加锁，无法对幻读中的搜索范围加锁，但要防止幻读，从逻辑上可以给这个搜索范围加锁，这类锁被称为谓词锁。
它类似于共享锁和独占锁，但它不是针对具体的某一行，而是对这个搜索条件加锁，谓词锁也分为共享谓词锁和独占谓词锁：
1. 如果事务A想要匹配某些条件的对象，它必须先检查现存的共享谓词锁，如果事务B持有任何满足这一查询条件对象的排他锁，那么A必须等到B释放它的独占锁后才允许查询；
2. 如果事务A想要写入，则必须检查旧值和新值 是否与现存的任何谓词锁匹配，如果有被持有，则A必须等待锁释放。

索引范围锁
不幸的是谓词锁性能不佳，如果活跃事务持有很多锁，检查匹配锁会非常耗时。
大多数2PL转而实现了索引范围锁（index range locking 或者叫 next key locking），我们的索引是一个B+树，特性是一颗多叉搜索树（查找平衡树），查询通过范围搜索。我们可以将事务的搜索条件转移到某个条件的索引上来，因为该索引的范围是大于等于搜索条件的（可能恰好所有条件都能匹配到联合索引），所以索引是一个更大的集合。如果能对这个索引的集合进行锁定，也能实现谓词锁要求的功能。也就是说，这个谓词锁是加在索引上面的，优势是可以很快的通过索引定位，而不是 暴力匹配现存的所有谓词锁。
举例：
SELECT * FROM bookings
WHERE room_id = 123 AND
      end_time > '2018-01-01 12:00' AND
      start_time < '2018-01-01 13:00';
在房间预订中，root_id、end_time、start_time如果有索引的话，：
1. 以root_id索引为例：使用数据库查找room_id = 123的现有预定，此时查询会获取一个在这个索引项的一个共享锁，当有其他写入时，必须要等待当前事务提交；

虽然锁的范围更大，影响的更大，但性能开销降低，所以这也是一种trade off。
如果查询条件没有可以挂载的索引，那就会退化到使用整张表的共享锁，此时数据库会阻止所有其他事务写入表格，性能会降低。
