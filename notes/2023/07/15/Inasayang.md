Reduce端的join与分组

-   最简单实现
    -   逐个遍历活动事件，并在用户数据库上查询
    -   性能差，吞吐量受数据库往返时间限制
-   获取用户数据库的副本（ETL从数据库备份中提取数据），放入与用户活动事件相同的分布式文件系统



排序-合并join

-   次级排序
    -   mapper对记录排序，被依赖的排在前面，让reducer先看到？
-   reducer每次处理一个用户的所有记录
-   mapper输出按关键字排序，reducer将来自join两侧的已排序列表合并



将相关数据放在一起

-   排序-合并join中，mapper和排序过程需要确保特定用户的join操作的所有必要数据放在一起，保证一次reducer调用



分组

-   设置mapper，键值对使用所需的分组关键字，分区和排序中，将相同reducer中有相同关键字的记录集合在一起
-   会话流程：手机特定用户会话的所有事件，发现用户的活动序列



处理数据倾斜（热点）

-   MapReduce作业只有在所有mapper和reducer都完成才能完成，必须等待最慢的reducer（木桶效应）
-   分散
    -   先运行抽样作业确定哪些属于热键
    -   真正运行时，将与热键有关的记录发送到随机选择的若干个reducer中
    -   join的其他输入，与热键相关的记录也需要被复制到该reducer中
    -   更好地实现并行处理，代价是需要复制
    -   Crunch中的共享join方法与此类型（不是抽样，而是明确指定热键）
-   物理分散
    -   hive的倾斜join
    -   在表格元数据中明确指定热键
    -   与热键相关的记录与其他文件分开存放
    -   对热键使用map端join



Pp. 380-384