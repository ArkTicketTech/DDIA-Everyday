## 将事情做正确

数据库的出错是持久化的，ACID尽可能地避免错误，强一致性牺牲性能，为了提高更好性能和可伸缩性的模型，弱一致性非常流行。

但如果需要更强的正确性保证，可串性化与原子提交是可靠的，但同时也有大家：它们通常只在单个数据中心工作，并限制了系统能够实现的规模与容错特效。

### 数据库的端到端原则

即使数据库安全，应用也可能有bug。



#### 正好执行一次操作



恰好一次语义：即使记录被处理了多次，但看起来好像就被处理了一次。

重试无法避免，但重试可能会带来副作用，比如收费两次，发送两次邮件等，所以操作最好是幂等的。

幂等：确保它无论是执行一次还是执行多次都具有相同的效果。

但是将不是天生幂等的操作变为幂等操作需要额外的工作：比如维护一个幂等表，用唯一key去做校验；还有从一个节点故障切换到另一个节点时做好防护，其实就是用版本号来过滤掉重试的操作。



#### 抑制重复





单条TCP能抑制重复，但因为重试的多条TCP无法避免下面的SQL：资金从一个账户到另一个账户的非幂等转移

```sql
BEGINTRANSACTION;
UPDATE accounts SET balance = balance +11.00 WHERE account_id =1234;
UPDATE accounts SET balance = balance -11.00 WHERE account_id =4321;
COMMIT;
```

上面的SQL必然不会在生产中出现，如果客户端发送commit请求后，由于网络中断和连接超时，没有接收到成功的响应但实际上转账是成功的，客户端可以重连到数据库并重试事务。

即使我们可以抑制客户端和数据库的重复，但用户终端也可能因为类似的原因进行重试，用户重试的话那就是另一个独立的事务，也谈不上重复了，但实际上转账却出错了，这种错误肯定是不可接受的





#### 操作标识符

要在通过几跳的网络通信上使操作具有幂等性，仅仅依赖数据库提供的事务机制是不够的 ，必须要需要考虑 **端到端（end-to-end）** 的请求流。 例如，可以为操作生成一个唯一的标识符（例如UUID），将其作为隐藏表单字段包含在客户端应用中，或者计算表单所欲相关字段的哈希来生成操作。如果web提交了两次POST请求，则这两个请求将具有相同的操作ID，这个ID可以一路传递到数据库记录下来，校验时就可以很方便的拿出来进行校验。



```sql
ALTER TABLE requests ADD UNIQUE (request_id);

BEGIN TRANSACTION;
    INSERT INTO requests
        (request_id, from_account, to_account, amount)
        VALUES('0286FDB8-D7E1-423F-B40B-792B3608036C', 4321, 1234, 11.00);
    UPDATE accounts SET balance = balance + 11.00 WHERE account_id = 1234;
    UPDATE accounts SET balance = balance - 11.00 WHERE account_id = 4321;
COMMIT;
```

这种方法就是之前说的幂等表，用唯一索引来进行约束。

#### 端到端原则

抑制重复事务的这种情况只是一个更普遍的原则的一个例子，这个原则被称为 **端到端原则（end-to-end argument）**。

在我们的例子中 **所讨论的功能** 是重复抑制。我们看到 TCP 在 TCP 连接层次抑制了重复的数据包，一些流处理器在消息处理层次提供了所谓的恰好一次语义，但这些都无法阻止当一个请求超时时，用户亲自提交重复的请求。TCP，数据库事务，以及流处理器本身并不能完全排除这些重复。解决这个问题需要一个端到端的解决方案：从终端用户的客户端一路传递到数据库的事务标识符。

端到端原则应用广泛：

1. 检查数据的完整性
2. 加密和认证



#### 在数据系统中应用端到端思考

数据库安全的属性并不能保证应用也是安全的，应用本身也需要采用端到端的措施，比如去重。

容错很难抽象，事务是一个成功的例子，事务将「并发写入、违背约束、崩溃、网络中断、磁盘故障」合并为两种可能：提交和中止。

但事务的代价是高昂的，尤其是分布式事务。

因此，探索对容错的抽象是很有价值的，它能使应用特定的端到端的正确性属性变得简单，而且还能在大规模分布式环境中提供良好的性能与运维特效。
