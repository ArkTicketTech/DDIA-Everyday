提起事务，似乎首先想到的是转账的例子，A先扣款，B再加款，要保证同时成功同时失败；

但事实上，即使是单个操作，也存在事务，比如批量更新了一批数据，更新到一半时发生异常，如果不进行处理就是一半正确一半错误。

或者说对多个表一系列连续的写操作执行到一半时，应用程序发生异常，同样会导致部分正确部分错误的数据交错在各个表中。

没有事务这个概念时，试想遇到这些问题该如何解决，在应用层解决肯定是有办法的，但是不得不设计一个精妙的方案，写大量的容错和补偿代码。

而事务就是为了简化应用编程模型而创建的，将一系列操作打包为一个原子操作，保证程序要么全部成功要么全部失败，全部失败可以再次重试即可，避免部分失败部分成功造成的心智负担。

## 事务的棘手概念

事务不是银弹，与其他技术一样，事务有优势和局限。

### ACID

ACID 代表 **原子性（Atomicity）**，**一致性（Consistency）**，**隔离性（Isolation）** 和 **持久性（Durability）**

#### 原子性- Atomicity


原子 不可再被分解的东西。把一组写操作打包为一个原子操作，这些操作要么全部成功，要么全部失败，不存在部分失败部分成功。

真是的业务中会经常出现这种需求，比如转账。

进程崩溃、网络连接中断、磁盘变满、某种完整性约束被违反。

如果错误产生而不能提交，则事务需要被中止，并且数据库需要撤销该事务已完成的写入操作。


#### 一致性

ACID中的一致性的概念时：对数据的一组特定约束必须始终成立，在转账的例子中，就是在任何时刻，只有当收款方收到款后，转账方才是支出成功。

一致性是一种结果，由应用层和数据库的特性来共同保证。


#### 隔离性

多个客户端同时访问数据库的同一记录时就会产生并发，并发不一定会有问题，但当遇到竞态条件时就会出现各种问题，可能是数据被覆盖、未预期的异常等。，

竞态条件：不恰当的执行时序导致了不正确的结果。最常见的竞态条件类型就是”先检查后执行“操作，即通过一个可能失效的观测结果来决定下一步的动作。

比如两个客户端同时在数据库增长一个计数器，每个客户端都需要读取计数器当前的值，然后加1，最后再回写新值。但事实上，在你观察到这个计数器的值 到 根据这个计数器采取了加1并回写 之间，另一个客户端在这期间将计数器已经成功加1，使得你的观察结果变得无效，从而导致数据丢失问题。

要避免竞态条件问题，就必须在一个客户端增长计数器时，通过某种方式防止其他客户端使用这个计数器，从而确保其他客户端只能在修改操作完成之前或者之后修改该计数器，而不是在修改状态的过程中。

隔离性就是专门来解决并发的问题的。数据库的隔离性是指，每个事务的执行是互相隔离的，每个事务都可以认为自己是系统中唯一正在运行的事务。如果所有的事务都是串行执行的，则任何时刻必然只有一个事务在执行，从而在根本上消除任何并发问题。

但实践中，这种强隔离性会有很大的性能损失。我们一般使用弱隔离性，弱隔离性的实现和影响后续会讲。

#### 持久性

持久性是数据库对数据安全的一种保证，完美的持久性是不存在的，单机系统的数据库，将数据持续的写入磁盘，相比于把数据放在内存，这就是一种持久性保证。

单机系统容易有单点故障，所以相比于单机系统，数据库集群的主从同步复制又提高了更高的持久性保证。

相比于单地存储，异地灾备进一步提高了持久性保证。
