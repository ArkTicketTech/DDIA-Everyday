## 检测并发写入
客户端并发写入相同的key，由于存在可变的网络延迟或者部分节点的故障，请求可能以不同的顺序到达不同的节点，如果每个节点只要接收到来自客户端的写入请求就简单地覆写某个键值，那么节点就会永久地不一致。
最后写入胜利
当客户端之间并不知道自己的写入是否比别人更优先时，他们就是并发的，为了让副本只存储最近的值，那就要对每个写入进行排序，自然的是为每个写入加上时间戳，然后挑选最大的时间戳作为 “最近的”，并丢弃具有较早时间戳的任何写入。这种冲突解决算法被称为 最后写入胜利（LWW, last write wins）。
LWW 实现了最终收敛的目标，但以 持久性 为代价：如果同一个键有多个并发写入，即使它们反馈给客户端的结果都是成功的（因为它们被写入 w 个副本），也只有一个写入将被保留，而其他写入将被默默地丢弃。
在数据库中使用 LWW 的唯一安全方法是确保一个键只写入一次，然后视为不可变，从而避免对同一个键进行并发更新。例如，Cassandra 推荐使用的方法是使用 UUID 作为键，从而为每个写操作提供一个唯一的键。

### 确定happens-before关系
系统中任意的两个写入A和B，只可能存在三种关系
1. A happens before B
2. B happens before A
3. A and B are concurrent

为了定义并发，事件发生的绝对时间先后并不重要，只要两个事件意识不到对方的存在，则称两个操作并发。在计算机网络中，只要由于网络问题导致，在事件发生时间差内，两者都不能意识到，则称其为并发的。

如果两个操作可以定序，则LLW；如果两个操作并发，则需要进行冲突解决。
所以非常关键的问题就是如何知道两个操作的happens-before关系？
想知道A和B的happens-before关系，还是有办法的。

1. 当客户端读取key时，服务器将返回所有未覆盖的值以及最新的版本号。客户端在写入前必须先读取。
2. 客户端的每次写入必须包含之前读取到的版本号，服务端在会对数据进行合并并维护一个更高的版本号；
3. 对于并发，数据库不会覆盖，而是保留多个并发值

由于每次写入某个key前都会先读取这个key的所有值，当前要写入的值肯定是 happens before 读取的值，如果写入时发现这个key有新的版本号，说明这个值与当前写入的值是有并发关系的。
对于并发的数据，不会选择覆盖，而是保留这些并发值。

### 合并并发写入的值
上面合并并发写入的值是做并集。
合并的复杂度其实很高，还要考虑移除等情况，比较专业的是设计特定的数据结构来支持合并，比如比较有名的CRDT。

### 版本向量
上面例子只考虑了单个副本。多个副本时，还需要考虑给版本号上加上副本的信息。



