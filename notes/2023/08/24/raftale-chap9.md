### 原子提交与两阶段提交

需要原子性的地方很多，比如事务ACID中的原子性，多对象操作时一起失败或者一起成功，还有二级索引与主数据的原子性。



#### 从单节点到分布式原子提交

对于在单个数据库节点执行的事务，原子性通常由**存储引擎**实现。当客户端请求数据库节点提交事务时，数据库将使事务的写入持久化（通常在预写入日志中），然后将提交日志追加到磁盘中的日志里。如果数据库在这个过程中崩溃，当节点重启时，事务会从日志中恢复，如果提交记录在崩溃之前成功的写入磁盘，则认为事务被提交；否则来自该事务的任何写入都会被回滚。

因此，在单个节点上，事务的提交主要取决于数据持久化落盘的顺序。首先是数据，然后是提交记录。事务提交或中止的关键决定时刻是磁盘完成写入提交记录的时刻。

如果要在多个节点上对多个对象实现事务（二次索引很可能位于与主数据不同的节点上），事务就不能轻易提交，因为一些节点成功，而另一些节点因为某些原因失败，很难回滚，同时还有一个重要的原因：事务提交必须是不可撤销的，因为一旦事务提交后，其结果就对其他事物可见，该数据就会影响后续的数据，这个原则构成了「读已提交」的隔离级别。

#### 2PC简介

2PC是一种用于实现跨多个节点的原子事务提交的算法，即确保所有节点提交或所有节点中止。它是分布式数据库的经典算法，但也在有些数据库内部有使用。

2PC使用一个通常不会出现在单节点事务中的新组件，协调者（也称为事务管理器）。协调者通常在请求事务的相同应用程序中以库的形式出现（例如嵌入在Java EE容器中），但也可以是单独的进程或者服务。

正常情况下，2PC事务以应用在多个数据库节点上读写数据开始，我们称这些数据库节点为参与者。当应用准备提交时，协调者**开始阶段1**：它发送一个prepare请求到每个节点，询问他们是否能够提交，然后协调者会跟踪参与者的响应：

1. 如果所有参与者都回答是，表示它们已经准备好提交，那么协调者会在**阶段2**发出提交请求，然后提交在参与者真正发生
2. 如果有任意一个参与者回答了否，那么协调者将在**阶段2**向所有节点发送中止请求。



#### 系统承诺

2PC实际上分为两个阶段，阶段1准备，阶段2得到所有节点确认后真正在单机上执行提交事务。

问题1：协调者确认所有节点都可以提交后，发出确认提交的请求，如果某个节点崩溃，如果保证原子性？

回答1：阶段2一旦参与者收到准备请求，参与者需要确保在任何情况下（包括崩溃）都能够提交事务，请求失败，协调者会不停的重试，直到成功。意味着节点崩溃恢复后，也依然要提交。
