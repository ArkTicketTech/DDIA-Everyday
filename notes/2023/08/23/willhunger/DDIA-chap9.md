### Distributed Transactions and Consensus
节点达成一致在很多场景中都非常重要，例如：
* 领导选举：在单主复制的数据库中，所有节点需要就哪个节点是领导者达成一致。如果出现脑裂现象，则会导致不同分区节点的数据不一致或者丢失。
* 原子提交：在支持跨多节点或跨多分区事务的数据库中，必须让所有节点对事务的结果达成一致。
> 原子提交的形式化与共识稍有不同：原子事务只有在 **所有** 参与者投票提交的情况下才能提交，如果有任何参与者需要中止，则必须中止。 共识则允许就 **任意一个** 被参与者提出的候选值达成一致。 然而，原子提交和共识可以相互简化为对方。 **非阻塞** 原子提交则要比共识更为困难

#### Atomic Commit and Two-Phase Commit (2PC)
事务原子性的目的是在多次写操作中途出错的情况下，提供一种简单的语义。事务的结果要么是成功提交，在这种情况下，事务的所有写入都是持久化的；要么是中止，在这种情况下，事务的所有写入都被回滚（即撤消或丢弃）。

##### From single-node to distributed atomic commit
对于单节点数据库节点执行的事务，原子性通常由存储引擎实现：
1. 当客户端请求数据库节点提交事务时，数据库将事务写入持久化（通常在 WAL 中）；然后将提交记录追加到磁盘中的日志中。
2. 如果数据库在过程中崩溃，当节点重启时，事务会从日志中恢复；如果提交记录在崩溃之前成功地写入磁盘，则认为事务被提交；否则来自该事务的任何写入都被回滚。

单节点上，事务的提交主要取决于数据持久化落盘的顺序：首先是数据，然后是提交记录。事务提交或终止的关键决定时刻是磁盘完成写入提交记录的时刻：在此之前，事务仍然有可能中止或崩溃。

但当涉及到多节点时，易发生违反原子性的情况：在某些节点上提交成功，在其它节点上提交失败。
如果某些节点提交了事务，但其它节点终止了事务，会导致节点间不一致。而且一旦在某个节点上提交了一个事务，如果事后发现它在其它节点上被中止了，它是无法撤回的。出于这个原因，一旦确定事务中的所有其他节点也将提交，节点就必须进行提交。

事务提交必须是不可撤销的 —— 事务提交之后，你不能改变主意，并追溯性地中止事务。这个规则的原因是，一旦数据被提交，其结果就对其他事务可见，因此其他客户端可能会开始依赖这些数据。这个原则构成了 **读已提交** 隔离等级的基础，在 读已提交 一节中讨论了这个问题。如果一个事务在提交后被允许中止，所有那些读取了 **已提交却又被追溯声明不存在数据** 的事务也必须回滚。

> （提交事务的结果有可能通过事后执行另一个补偿事务（compensating transaction）来取消，但从数据库的角度来看，这是一个单独的事务，因此任何关于跨事务正确性的保证都是应用自己的问题。）
