### 强制约束

唯一性约束：

1. 用户和电子邮件地址必须唯一标识用户；
2. 文件存储服务不能包含多个重名文件；
3. 两个人不能在航班和剧院预定同一位置；

其他类型的约束：

1. 确保账户余额永远不会变成负数；
2. 确保不会超卖库存；
3. 或者会议室没有重复的预定

如何保证这些约束？

#### 唯一性约束需要达成共识

分布式环境中，强制执行唯一性约束需要共识：如果存在多个具有相同值的并发请求，则系统需要决定冲突操作中的哪一个被接受，并拒绝其他违背约束的操作。

#### 基于日志消息传递中的唯一性

流处理器在单个线程上依次消费单个日志分区中的所有消息，因此，如果日志是按需要确保唯一的值做的分区，则流处理器可以无歧义地、确定性地决定几个冲突操作中的哪一个先到达。例如，在多个用户尝试宣告相同用户名的情况下：

1. 每个对用户名的请求都被编码为一条消息，并追加到按用户名散列值确定的分区；
2. 流处理器依次读取日志中的请求，并使用本地数据库来追踪哪些用户名被占用，可申请用户名的请求，它都会记录该用户名，并向输出流发送一条成功消息；用户名被占用的请求则会发送一条拒绝消息；
3. 客户端监视输出流，等待与其请求相对应的成功或拒绝消息；

该算法基本上与「使用全序广播实现线性一致的存储」 中的算法相同。它可以简单地通过增加分区数伸缩至较大的请求吞吐量，因为每个分区都可以被独立处理。

该方法不仅适用于唯一性约束，而且适用于许多其他类型的约束。其基本原理是，任何可能冲突的写入都会路由到相同的分区并按顺序处理。冲突的定义可能取决于应用，但流处理器可以使用任意逻辑来验证请求。


#### 多分区请求处理

在数据库的传统方法中，执行此事务需要跨全部三个分区进行原子提交，就这些分区上的所有其他事务而言，这实质上是将该事务嵌入一个全序。而这样就要求跨分区协调，不同的分区无法再独立地进行处理，因此吞吐量很可能会受到影响。

当涉及到多个分区时，确保原子操作就需要额外的任务。比如三个分区的对象：

1. 请求ID
2. 收款人账户
3. 付款人账户

分布式事务可以保证原子提交，但开销太大，其实还有另一种方法，利用日志和端到端的原则，使用分区日志可以达到等价的正确性而无须原子提交，核心思想就是将多对象操作记录下来转变成单对象操作，然后单对象再给出多对象的操作指令，指令必须成功，并通过端到端的原则来保证幂等性：

1. 从账户A向账户B转账的请求由客户端提供一个唯一的请求ID，并按请求ID追加写入相应分区日志；
2. 流处理器读取请求日志，对于每个请求消息，它向输出流发送两条消息：付款人账户A的借记指令（按A分区），收款人B的贷记指令（按B分区）。被发出的消息中会带有原始的请求ID
3. 后续处理器消费借记/贷记指令流，按照请求ID去重，并将变更应用到账户余额。



为了避免对分布式事务的需要，我们将请求持久化记录转化为单条消息，然后从这一条消息衍生出贷记指令和借记指令。

如果流处理器在步骤2崩溃，则它会从上一个存档点恢复处理，也就是重试，由于请求带有了原始请求ID，所以可以保证幂等性。也就是说，借记和贷记两个必须成功。如果两个要失败，会在第一步就失败。

如果要确保付款人的账户不会因为转账而透支，可以使用一个额外的流处理器来维护账户余额并校验事务（按付款人账户分区），只有有效的事务会被记录在步骤1的请求日志中。

这里说的维护余额我认为是 再维护一张表，记录扣款后的真正余额吧。每次都来进行一个比较。


通过将多分区事务分解为两个不同分区方式的阶段，并使用端到端的请求ID，我们实现了同样的正确性属性（每个请求对付款人和收款人都恰好生效依次）。

这个想法与我们在多分区数据处理中的想法类似。
