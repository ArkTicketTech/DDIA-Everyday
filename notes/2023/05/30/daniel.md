## Quorum一致性的限制条件

- 由于 w + r > n 时，总会至少有一个节点（读写子集至少有一个节点的交集）保存了最新的数据，因此总是期望能读到最新的。
- 当 w + r ≤ n 时，则很可能会读到过期的数据。
- 在 w + r > n 时，有一些边角情况（corner case），也会导致客户端读不到最新数据：
    1. 使用宽松的 Quorum 时（n 台机器范围可以发生变化），w 和 r 可能并没有交集。
    2. 对于写入并发，如果处理冲突不当时。比如使用 last-win 策略，根据本地时间戳挑选时，可能由于时钟偏差造成数据丢失。
    3. 对于读写并发，写操作仅在部分节点成功就被读取，此时不能确定应当返回新值还是旧值。
    4. 如果写入节点数 < w 导致写入失败，但并没有对数据进行回滚时，客户端读取时，仍然会读到旧的数据。
    5. 虽然写入时，成功节点数 > w，但中间有故障造成了一些副本宕机，导致成功副本数 < w，则在读取时可能会出现问题。
    6. 即使都正常工作，也有可能出现一些关于时序（timing）的边角情况。

因此，虽然 Quorum 读写看起来能够保证返回最新值，但在工程实践中，有很多细节需要处理。

如果数据库不遵守之前副本滞后小节引入的几个一致性保障，前面提到的异常仍然可能会发生。

### 1 一致性监控

**监测数据库更新速度的重要性**
监测数据是否过时，可以了解复制副本的健康状况，如果落后太多，可以及时找到原因

**领导者复制和无领导者复制的一致性监控区别**

- 基于领导者的复制，写入按照相同的顺序应用于领导者和跟随者，每个节点在复制日志中都有一个位置，可以确定复制延迟（lag）的进度
- 无领导者复制中，写入没有固定的顺序，副本的落后进度变得难以界定。如果系统只使用读时修复策略，则对于一个副本的落后程度是没有限制的。读取频率很低数据可能版本很老。

**测量副本陈旧度的研究**
最终一致性是一个故意模糊的保证，将陈旧度测量包括在数据库的标准指标集中将是很好的做法，但是对于可操作性，重要的是能够量化“最终一致性”。

### 2 松散的Quorums和Hinted Handoff

正常的 Quorum 能够容忍一些副本节点的宕机，在大型集群（节点数量显着大于n）中，最初选中的 n 台机器，由于种种原因（宕机、网络问题），导致无法达到法定读写数目，则此时有两种选择：

- 为所有无法达到w或r节点法定人数的请求返回错误
- 接受写入，并将它们写入可达但不属于通常存储值的n个节点之一的一些节点

后者被称为松散的法定人数（**sloppy quorum**）：写入和读取仍然需要w和r的成功响应，但是其所在节点集合可以发生变化。一旦网络中断得到修复，任何一个节点暂时接受的另一个节点的写入都会被发送到应该在的节点，这被称为提示性移交。

松散的法定人数特别适用于增加写入可用性：只要有任何w个节点可用，数据库就可以接受写入。然而，这意味着即使w + r > n，也无法确定读取键的最新值，因为最新值可能已经暂时写入n之外的一些节点。因此，松散的法定人数实际上不是传统意义上的法定人数。它只是一种耐久性保证，即数据在某个地方存储在w个节点上。在提示性移交完成之前，不能保证r个节点的读取将看到它。在所有常见的Dynamo实现中，松散的法定人数都是可选的。在Riak中，它们默认启用，在Cassandra和Voldemort中，它们默认禁用。

### 3 **多数据中心**

无主模型也适用于系统多数据中心部署。

为了同时兼顾**多数据中心**和**写入的低延迟**，有一些不同的基于无主模型的多数据中心的策略：

1. 其中 Cassandra 和 Voldemort 将 n 配置到所有数据中心，但写入时只等待本数据中心副本完成就可以返回。
2. Riak将客户端和数据库节点之间的所有通信保持在一个数据中心内，跨数据中心的复制在后台异步进行。
