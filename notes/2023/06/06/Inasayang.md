复制滞后问题

-   读自己的写
    -   写入主节点，读从从节点,但是对于异步复制，当读取时，数据还没到达从节点
    -   需要read-after-write一致性（写后读一致性或读写一致性）,保证总能看到自己最新的更新,但是对其他用户不保证
    -   方案
        -   用户访问可能被修改的内容，从主节点读取，反之，从从节点读取。（要求查询前，已经知道内容是否可能会被更改）
            -   如，社交网络上的用户首页信息通常只能本人更改，所以，读取用户自己的首页总是从主节点读取，其他人的总是从从节点读取
        -   如果用户的大部分内容都可能被所有用户修改，会导致大部分流量都经过主节点，那么上述方案不可行。需要借助其他方案，如，最新更新时间
            -   更新一分钟之内，总是从主节点读取，并监控从节点的复制状态，避免从滞后超过一分钟的从节点读取
        -   客户端读请求中包含最近更新的时间戳
            -   时间戳可以是逻辑时间戳（写入顺序的日志序列号）或实际系统时钟（需要时钟同步）
        -   如果存在多DC，必须路由到主节点所在的DC
        -   多设备访问，需要跨设备的写后读一致性（在A设备上修改了信息，在B设备上查看）
            -   元数据全局共享
            -   如果多DC，可能无法确保连接同一个DC。（总从主节点读取）
-   单调读
    -   比强一致性弱，比最终一致性强
    -   保证如果进行多次读取，绝对不会看到回滚现象（即读取较新值后又发生读取旧值的情况）
    -   实现方式：确保用户总是从固定的同一副本执行读取（不同的用户可以从不同的副本读取）
        -   如，基于用户ID的哈希方法，副本失效，则必须路由到另一个副本
-   前缀一致读
    -   按照某个顺序的写请求，读请求也应该按照这个顺序，防止先果后因
    -   分区分片数据库中会出现的问题。分布式数据库中，不同的分区独立运行，没有全局写入顺序
    -   方案
        -   任何具有因果顺序关系的写入都由一个分区完成（效率低）
        -   `Happened-before`关系与并发



Pp. 154-160