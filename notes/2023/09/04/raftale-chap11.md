## 数据库和流

事实上，复制日志是一个由数据库写入事件组成的流，由主库在处理事务时生成。从库将写入流应用到它们自己的数据库副本，从而得到相同数据的精确副本。



### 保持系统同步

没有一个系统能满足所有的数据存储、查询和处理需求，例如，OLTP数据库来为用户请求提供服务，使用**缓存**来加速常见请求，使用**全文索引**来处理搜索查询，使用数据仓库进行分析。每一种技术都有自己的数据副本，并根据自己的目的进行存储方式的优化。



多个地方的数据需要保持同步，如果某个项目在数据库中被更新，它也应当在缓存、搜索引擎和数据仓库中被更新。数据仓库的更新通常由ETL（Extract-Transform-Load）进行执行，通常是先取得数据库的完整副本，然后执行转换，并批量加载到数据仓库中。

如果周期性的完整数据库转存储过于缓慢，有时会用双写，其中应用代码在数据变更时明确写入每个系统：例如，首先写入数据库，然后更新搜索引擎，然后使缓存项失效。

但双写会有一些问题，第一个是竞争条件，并发的客户端写入不同的值，由于时序的问题可能导致缓存和数据库不一致。除非有一些额外的并发检测机制，例如版本向量。

第二个问题是双写，其中一个可能会失败，而另一个成功，这是一个容错问题，而不是并发问题。如果要保证原子提交，需要使用分布式事务。



### 变更数据捕获

如果是捕获数据库的复制日志，不断的将相同的变更应用到搜索索引，就可以避免双写遇到的问题。

如果变更日志以相同的顺序应用，则可以预期衍生数据与原始数据是一致的，衍生数据系统只是变更流的消费者。



#### 变更数据捕获的实现

我们可以将日志消费者叫做衍生数据系统，从本质上说，变更数据捕获使得一个数据库称为领导者，并将其他组件变为追随者。基于日志的消息代理非常适合从源数据库传输变更事件，因为它保留了消息的顺序（单线程读取单分区）。

数据库触发器可以实现变更数据捕获，但不推荐；

更流行的还是解析复制日志，需要专门的组件。

数据变更与记录系统写数据是异步的，缓慢的消费者不会过度影响记录系统。但所有的复制延迟带来的问题也都会出现。



#### 初始快照

由于磁盘容量的问题，日志不会保存永久的，所以同步一般是选择一个时间点的快照，全量同步后再应用最近的日志解析。就跟设置新从库差不多。



#### 日志压缩

日志压缩：丢弃掉所有重复的内容，只保留每个键的最新更新。

日志压缩可以提高日志的存储量，如果恰好日志是全量的，那无论何时都可以直接通过日志进行同步。

#### 变更流的API支持

逐渐成为主流
