### 超时与无穷的延迟

如果超时是故障检测的唯一可靠方法，那么超时应该等待多久。

长时间的超时意味着长时间的等待，直到一个节点被宣告死亡，但在这段时间内，用户必须等待；

短时间的超时可以更快的检测到故障，但容易误判，可能该节点只是因为负载过高暂时响应的慢。

过早的声明一个节点死亡的危害：

1. 它的职责需要转移到其他节点，会给其他节点和网络带来额外的负担，如果系统已经处于高负荷状态，过早宣告节点死亡会使问题更严重，特别是节点实际上没有死亡，只是负载暂时过高；
2. 极端情况下，负载转移到其他节点可能会导致级联失效（cascading failure)

`2d+r`会是一个合理的超时设置，`d`是网络中数据包传输时间永远都不会比`d`更长，要么丢失，要么成功。 `r`是一个非故障节点总是能在该时间内处理一个请求。



### 网络拥塞和排队

数据包延迟的最大可能是排队，繁忙的网络链路上，发送方排队发送、交换机转发排队，接收方排队处理。

在公有云和多租户数据中心，资源被许多客户共享。共享资源很可能被小部分的使用者大量占用，会增加其他用户的 网络延迟。因此系统不是使用配置的常量超时时间，而是连续测量响应时间及其变化，并根据观察到的响应时间分布自动调整超时时间。这可以通过Phi Accrual故障检测器来完成，该检测器在Akka和Cassandra中使用。TCP的超时重传机制也是以类似的方式工作。



### 同步网络和异步网络

传统固定电话网络（非蜂窝，非VoIP）的网络是同步的，即使数据经过多个路由器，也不会收到排队的影响，网络的最大端到端延迟是固定的，称之为有限延迟。

TCP连接是分组交换协议，不得不忍受排队和网络无限延迟。



可以将有限延迟和

资源静态分配和资源动态分配，静态分配带宽是固定的，网络延迟是固定的；动态分配是需要竞争的，但最大限度的利用了线路，它的成本更低，但延迟是可变的无上限的。

网络中的可变延迟不是一种自然规律，而是成本/收益权衡的结果

### 不可靠的时钟

单一的时钟的精确度受限于物理硬件，但分布式系统中每台单机都有时钟，所有单机的时钟不一定都是相等的（也许是硬件、也许是人为错误）。

另外，分布式系统中，消息通过网络从一台机器传送到另一台机器需要时间，网络延迟是可变的，如果A消息先发送，B消息晚于A发送，因为网络延迟，B消息先到达。这个事实很难确定在涉及多台机器时发生事情的顺序。



#### 单调钟与日历时钟

日历时钟就是我们的日常可见的时间，它通常与NTP协议同步，不适用于测量时间间隔；

单调时钟适用于测量时间间隔，单调时钟的绝对值是没有意义的，单调时钟是不需要同步的。



#### 时钟同步和准确性

时钟处于各种原因并不总是可靠和准确的



#### 依赖同步时钟

不正确的时钟对系统有危害性且很难发现。

因此，如果你使用需要同步时钟的软件，必须仔细监控所有机器之间的时钟偏移，偏移过大的节点应该被及时宣告死亡，从集群移除。



##### 有序事件的时间戳

![img](https://cdn.nlark.com/yuque/0/2023/png/32473878/1692280226792-5845b558-bcce-4d85-ae1d-8889d8f98d9b.png)

多主复制的数据库中，客户端A在节点1写入x=1，写入被复制到节点2和节点3；客户在节点3上对x+1，写入被复制到节点2。

节点2的视角来看，写入x=1的时间点是42.004，写入x=2的时间点是42.003（当一个写入被复制到其他节点时，它会根据发生写入的节点上的日历始终标记一个时间戳），由于写入x=1的时间大于写入x=2，所以节点2会选择接受x=1，而丢弃掉x=2。

这种冲突策略被称为最后写入胜利（LWW），之前复制章节有讲到，是多主复制和无主复制针对并发写入的一种策略。



这里的问题是：依赖时钟，在多个节点上对事件进行排序，由于节点之间的时钟并不是一致的，结果是有可能不准确的。

1. 数据库写入可能会神秘消失：具有滞后时钟的节点无法覆盖之前具有快速时钟的节点写入的值。
2. LWW无法区分高频顺序写入和真正并发写入，需要额外的因果关系机制，如版本向量，以防止违背因果关系。

因此，通过保留最近的 值并放弃其他值来解决冲突的思路中，这个“最近”的定义取决于本地的日历时钟，这很可能是不正确的，即使使用严格同步的NTP时间，不同节点的时间偏移会导致一个数据在时间戳100ms（发送者的时钟）时发送，并在99ms（接收者的时钟）时到达的奇怪现象。

对于排序时间来说，基于递增计数器的逻辑时钟是更为安全的选择，逻辑时钟仅测量时间的相对顺序。测量实际时间的日历时钟和单调钟也被称为物理时钟。



##### 时间读数存在置信区间

由于时间漂移的存在，将时间看成一个点是没有意义的，它更像是一段时间范围：一个系统可能以95%的置信度认为当前时间处于本分钟内的10.3秒和10.5秒之间。硬件厂商应该提供这个置信区间，

 Spanner 中的 Google TrueTime API明确提供了本地时钟的置信区间。

##### 全局快照的同步时钟

事务中的快照隔离会使用单调递增的事务ID，分布式系统中，这个事务ID如何保证单调递增？

事务ID必须反映因果关系，如果事务B读取由事务A写入的值，则事务B必须有比事务A更大的事务ID，否则快照无法保持一致。在有大量的小规模、高频率的事务场景下，在分布式系统中创建事务ID称为一个难以处理的瓶颈。



是否可以使用同步时钟的时间戳作为事务ID？如果我们能够获得足够好的同步性，那么更晚的事务会有更大的时间戳。当然，问题在于时间是一个置信范围。

Spanner以这种方式实现数据中心的快照隔离，它使用True Time API报告的时间置信区间。如果有两个时间置信区间，[A_earliest, A_latest]，[B_earliest, B_latest]，定义B在A后发生，只有当A_earliest<A_latest<B_earliest<B_latest时才能成立。当区间重叠时，不能确定A和B的发生顺序。

所以要拿出两个具有先后顺序的时间戳，那就要在拿出第一个后等待置信区间长度时间后再拿出第二个。

为了确保事务时间戳反映因果关系，在t时刻提交写事务时，应带故意等待置信区间长度的时间a，这样就会在t+a后的时间提交t的时间。这样可以确保任何读取数据的事务处于t+a后的时间，读取一定是在写之后的动作，因为它们的置信区间不会重叠。相反的是，如果在t时刻提交了t时间的写事务，那读事务在t+x时刻（x < a）读取，此时t+x并不一定晚于t（因为置信区间，t时间真正的时间可能是t+a），真正的时间可能小于写的时间，但却能够看到写的数据，就破坏了因果性。

这里的细节太多，现在思考感觉也不完全，后续需要再看





### 进程暂停

分布式系统中使用危险时钟的另一个例子。



假设有一个数据库，每个分区只有一个领导者，只有领导者被允许写入，一个节点如何知道它仍然是领导者（它没有被别人宣告死亡），并且它可以安全的接受写入。

一种选择是领导者从其他节点获得一个租约lease，类似一个超时的锁，任何时刻只有一个节点可以持有lease，因此，当一个节点获得一个lease时，它就知道自己时领导者，直到lease到期。为了保持领导地位，节点必须周期性的在lease过期前续约。

如果节点发生故障，就会停止续约，另一个节点可以接管。

```java
while (true) {
  request = getIncomingRequest();
  // 确保租约还剩下至少 10 秒
  if (lease.expiryTimeMillis - System.currentTimeMillis() < 10000){
    lease = lease.renew();
  }

  if (lease.isValid()) {
    process(request);
  }
}
```

如果程序执行中出现了意外的停顿，比如线程在lease.isValid()行停留了15秒，然后才继续，但15秒超过了10秒，一开始的请求还没有被处理完，租约已经过期了，另一个节点接管了领导。所以这段代码不会注意到租约已经到期，会继续处理接下来的请求，直到下一个迭代。但这个请求可能会产生一些不安全的动作。





一个线程可能会暂停很长时间，一个很常见的例子就是JVM的GC，stop the world会停止所有正在运行的线程。



分布式系统的节点，必须假定其执行可能在任意时刻暂停相当长的时间，即使在一个函数的中间。暂停期间，世界的其他部分在继续运转，甚至可能因为该节点没有响应而被宣告死亡。



#### 响应时间保证

某些软件的运行环境要求很高，软件必须要有一个特定的截至响应时间，不在特定时间响应可能会导致严重的损失，比如飞机、火箭、汽车必须对其传感器输入做出快速而可预测的响应。如果截止时间不满足，可能会导致整个系统的故障，这就是所谓的 **硬实时（hard real-time）** 系统。

例如，如果车载传感器检测到当前正在经历碰撞，你肯定不希望安全气囊释放系统因为 GC 暂停而延迟弹出。


 对于大多数服务器端数据处理系统来说，实时保证是不经济或不合适的。因此，这些系统必须承受在非实时环境中运行的暂停和时钟不稳定性。



#### 限制GC影响

带有GC的语言也能用在延迟敏感的系统，但需要一定的处理技巧。

如果运行时可以警告应用程序一个节点很快需要 GC 暂停，那么应用程序可以停止向该节点发送新的请求，等待它完成处理未完成的请求，然后在没有请求正在进行时执行 GC。这个技巧向客户端隐藏了 GC 暂停，并降低了响应时间的高百分比。一些对延迟敏感的金融交易系统使用这种方法。



这个想法的一个变种是只用垃圾收集器来处理短命对象（这些对象可以快速收集），并定期在积累大量长寿对象（因此需要完整 GC）之前重新启动进程。一次可以重新启动一个节点，在计划重新启动之前，流量可以从该节点移开。所以经常发布是一件好事情>.>。

这些措施不能完全阻止垃圾回收暂停，但可以有效地减少它们对应用的影响。
