## 复制延迟问题

回顾一下我们为什么要复制（多副本）：

1. 可用性
2. 可伸缩性
3. 低延迟

**最终一致性**：Leader和Follower在某一时刻可能并不同步，此时如果同时对Leader和Follower读取，会读取到不同的数据。但Leader和Follower最终会达到同步。

为什么会造这么一个概念呢？

如果是同步复制，也会造成Leader和Follower在某一时刻可能并不同步，但是同步过程中如果禁止读，就不会让客户端读到不一致的结果。

如果是异步复制，此时自然会允许复制过程中的读请求，很容易出现读取到的数据不一致的情况。

> 在实际中，网络通常比较快，**副本滞后（replication lag）**不太久，也即这个**最终**   **通常**不会太久，比如 ms 级别，最多 s 级别。但是，对于分布式系统，谁都不敢打包票，由于网络分区、机器高负载等等软硬件问题，在极端情况下，这个*最终*可能会非常久。

总之，**最终**是一个非常不精确的限定词。

#### 问题1 读己所写

看图：

<img src="https://wtsclwq.oss-cn-beijing.aliyuncs.com/ch05-fig03.png" style="zoom:33%;" />

- 时刻1：User1234首先向集群写入了一条数据，Leader在收到写请求之后开始将数据变更日志复制到Followers（异步）
- 时刻2：User1234向进取者的Follower3读取刚才自己写入的数据，结果读不到

**为什么会发生这种问题**：

异步复制，导致User1234错误的认为自己的写入已经完全应用到了集群中

**如何解决：**

**读写一致性（read-after-write consistency）**

**怎么实现：**限制读取的目的地

1. 对于客户端可能会写入（更新）的数据，限制只能从Leader读取，书上给的例子是：

   > 社交网络上的用户个人资料信息通常只能由用户本人编辑，而不能由其他人编辑。因此一个简单的规则就是：总是从主库读取用户自己的档案，如果要读取其他用户的档案就去从库。

   这样保证了用户的操作是符合预期的，我更改了我的资料->我再查询就能得到更新后的资料，但在底层其实此时读到的可能也是其他用户的旧数据。

2. 第一张方法在个别情况下会失去可伸缩读的优势（如果每个客户端都能访问基本所有数据）。因此**客户端**可以维护数据被更新数据的时间戳，向某个节点读的时候，检查该节点上数据的时间戳，不达标就换Leader或者其他Follower，也可以等待复制。

**其他问题**：

1. 节点异地分布（多数据中心）：这样在转发给Leader时，就需要多加一步，Follower->Follower中心路由->Leader中心路由->Leader
2. 用户多设备客户端：需要使用用户ID来维护时间戳
