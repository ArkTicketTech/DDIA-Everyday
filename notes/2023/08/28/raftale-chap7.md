### 成员关系和协调服务
Zookeeper和etcd被设计为容纳少量完全可以放在内存中的数据，这些少量的数据会通过容错的全序广播算法复制到所有节点上。正如前面讨论的那样，数据库复制需要的就是全序广播：如果每条消息代表对数据库的写入，则以相同的顺序应用相同的写入操作可以使副本之间保持一致。

Zookeeper模仿了Chubby锁服务，不仅实现了全序广播，还构建了一组有趣的其他特性：

1. 线性一致性的原子操作：使用原子CAS操作可以实现锁，如果多个节点尝试执行相同的操作，只有一个会成功，共识协议保证了操作的原子性和线性一致性，即使节点发生故障或者网络中断；分布式锁通常以租约的形式实现，租约有一个过期时间，以便在客户端失效时的情况下最终能被释放
2. 操作的全序排序：Zookeeper可以通过全序化所有操作来给每个操作提供一个单调递增的事务和版本号，可以用作领导者选举时需要的防护令牌。
3. 失效检测：客户端在zookeeper服务器上维护一个长期会话，客户端和服务器周期性的交换心跳包来检查节点是否还活着。即使连接暂时中断，或则和zookeeper节点失效，会话仍然保持活跃状态。但如果心跳停止的持续时间超出会话超时，zookeeper会宣告该会话已经死亡，会话持有的任何锁都可以配置为自动释放。
4. 变更通知：客户端不仅可以读取其他客户端创建的锁和值，还可以监听它们的变更，因此，客户端可以直到另一个客户端何时加入集群或发生故障。通过订阅通知，客户端不用再通过频繁轮询的方式来找出变更。

在上面的4个功能中，只有线性一致的原子操作才真的需要共识，但正是这些功能的组合，使得像zookeeper这样的系统在分布式协调中非常有用。


#### 将工作分配给节点

另一种zookeeper适合的场景是选举领导，假设你有多个进程实例或服务，需要选择其中一个实例作为主库或首选服务。如果领导者故障，应该再选举新的领导者。

另一个例子：当你有一些分区资源（数据库、消息流、文件存储、分布式Actor系统等），并需要决定将哪个分区分配给哪个节点时。当新节点加入集群时，需要将某些分区从现有节点移动到新节点，以实现分区再平衡；当节点被移除或者失效时，其他节点需要接管失效节点的工作。

这类任务可以通过在zookeeper中明智的使用原子操作，临时节点与通知来实现，如果设计得当，这种方法允许应用自动从故障中恢复而无需人工干预。


应用最初只能在单个节点上运行，但最终可能会增长到数千个节点。试图在如此多的节点上进行多数投票是非常低效的，相反，zookeeper在固定数量的节点上运行，并在这些节点之间执行其多数票。zookeeper提供了一种将部分功能（共识算法、故障检测）外包给外部服务的方法。

通常来说，zookeeper所管理的数据只会很低频的改变，如果上百万的qps，那可以使用其他工具，如bookkeeper。


#### 服务发现

由于无限的网络延迟，无法可靠的检测到另一个节点是否发生故障，但是如果你通过共识来进行故障检测，那么节点可以就哪些节点应该被认为是存在或者不存在达成一致。达成一致对系统来说非常重要，否则系统将会混乱。

## 本章小结

1. 线性一致性：多个副本数据看起来好像只有一个副本，且其上所有操作都是原子性的生效。它使数据库表现得好像单线程程序中的一个变量一样，但它有着速度缓慢的缺点，特别是在网络延迟很大的环境中。
2. 因果性：比线性一致性较弱的一致性模型，允许存在并发的事件。因果一致性没有线性一致性的协调开销，而且对网络问题的敏感性要低的多。
3. 即使捕获到因果关系，有些事情也不能通过这种方式实现。在注册用户名的例子中，我们需要确保用户名是唯一的，并拒绝同一用户名的其他并发注册，如果一个节点要通过注册，则需要知道其他的节点没有在并发抢注同一用户名的过程中，这个问题引领我们走向共识。
4. 共识意味着就某件事情一致同意，且这一决定不可撤销。与共识问题等价的问题是：

1. 1. 线性一致性的CAS寄存器：寄存器需要基于当前值是否等于操作给出的参数，原子地决定是否设置新值。
   2. 原子事务提交：数据库必须决定是否提交或中止分布式事务
   3. 全序广播：消息系统必须决定传递消息的顺序
   4. 锁和租约：当几个客户端争抢锁或租约时，由锁来决定哪个客户端成功获得锁
   5. 成员/协调服务：给定某种故障检测器（比如超时），系统必须决定哪些节点活着，哪些节点会因为会话超时需要被宣告死亡
   6. 唯一性约束：当多个事务同时尝试使用相同的键创建冲突记录时，约束必须决定哪一个被允许，哪些因为违反约束而失败
