## 复制日志的实现

1. 基于语句的复制：主库记录下执行的每个写入请求，并将该语句发送给从库
   1. 问题：非确定性函数如rand() now()会因为时间的不同而出现数据上的不一致；自增列和有副作用的语句带来的麻烦；
   2. 这是一种场景很受限的方式，一般不用这种方式
2. 传输预写式日志（WAL）：该日志包含了所有数据库写入的仅追加字节序列
3. 基于行的逻辑日志的复制：对复制和存储引擎使用不同的日志个数，将逻辑日志与存储引擎的内部实现解耦。
4. 基于触发器的复制：通过触发器来更改数据，易出错，场景有限，不常用
> 不是很明白WAL和逻辑日志的区别？还需要研究下

## 复制延迟是什么
基于领导者的主从复制，异步复制的从库的数据对用户来说略有延迟，因为主库的写入并没有等待从库响应，就直接确认成功了。对于读多写少的业务，客户端的读一般是走的读库，如果客户端写入主库后立刻读从库，可能因为延迟导致没有立刻读到自己写入的数据。 异步复制一般来说，延迟在几十毫秒内，客户端是感觉不到延迟的，但有时因为大批量的写入接近系统极限、网络、系统各种问题，延迟会达到秒级以上。

## 复制延迟会带来什么问题
1. 读写延迟
2. 时光倒流
3. 因果关系混乱

### 读写延迟
这是最普遍的问题，解决方案的原则是保证用户能立刻读到写入的数据
1. 对于用户可能修改过的内容，总是从主库读取；
2. 跟踪写入时间，写入后的一分钟内，从主库读，一分钟后的从读库中读
3. 监控从库的复制延迟，防止向任何滞后主库超过一分钟的从库发出查询（智能切换读的源）
4. 客户端记住最近一次写入的时间戳，通过在从库中判断时间戳来判断是否在该从库中读取，这个时间戳必须是一个逻辑上的时间戳。

有的解决方案有点复杂，但做业务时，一般的原则是：
1. 用户读自己的写走主库
2. 避免用户写入后马上查看，引导用户暂时去一个新的页面
3. 核心主流程走主库，在系统层面避免能影响复制延迟的操作；
4. 非核心业务读操作走读库；

### 时光倒流 - 单调读
如果用户先后从不同从库读取，不同从库的不一样的延迟可能造成用户先看到有写入的内容，再刷新一下又没了，让用户感到困惑。单调读可以保证这种异常不会发生，单调读就是：确保每个用户总是从同一个副本来进行读取，不同用户可以从不同的副本读取。
> 可以基于用户ID的hash来选择读库

### 因果关系混乱 - 一致前缀读
本来有因果关系的内容因为不同从库的延迟导致观察者看到了 时间错乱的会话。
防止这种异常，需要保证：如果一系列写入按照某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。
一种解决方案是：确认任何因果相关的写入写入相同的分区。
