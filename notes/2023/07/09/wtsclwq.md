当然如果一个数据库提供了快照隔离的级别 ，那么就起可以用MVCC实现各个等级了，而不需要单独设置一些策略：

1. **读已提交**在查询语句粒度使用单独的快照，快照粒度更小，因此性能更好。
2. **快照隔离**在事务粒度使用相同的快照（主要解决**不可重复读**问题）。

举例：pg如何实现MVCC：

1. 事务开始时，分配一个唯一的自增ID
2. 事务的写入操作会修改数据上的事务ID字段，表示该字段的版本为XX

<img src="https://wtsclwq.oss-cn-beijing.aliyuncs.com/fig7-7.png" alt="img" style="zoom:50%;" />

`create_by`和`delete_by`字段分别表创建该行的事务id以及标记删除该行的事务的id

#### 快照的可见性规则

事务A开始执行时，

1. 对于其他正在运行的早于事务A的事务BCD的写入对A是不可见的
2. 被中止的事务写入会被忽略
3. 事务A执行时，任何晚于事务A的其他事务的写入对A是不可见的
4. 其他的数据对于事务A来说都是可见的

> 从另外一个角度来讲，如果一个对象的版本：
>
> 1. 在事务开始时，创建该版本的事务已经提交。
> 2. 未被标记删除，或被标记删除的事务尚未提交。
>
> 则该对象版本对改事务可见。

### 索引和快照隔离

索引应该和快照同步更新吗？如果有多个版本的数据，如何维护多个版本的索引？

> 一种选择是使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本。

之前看过BoltDB的源码，这是LMDB的变种，使用的是仅追加/写时拷贝的B+Tree来实现MVCC，每次更新都会引起从Root到Leaf的路径全部修改（一些统计信息），BoltDB每次都会生成一个新的root，那么每个时刻内存中可能就会有多个B+Tree，以此来实现MVCC。

### 可重复读和明明困惑

最经典的隔离级别只有RU、RC、RR和Serializability，定义标准时还没有快照隔离

> PostgreSQL 和 MySQL 称其 **快照隔离** 级别为 **可重复读（repeatable read）**，因为这样符合标准要求，所以它们可以声称自己 “标准兼容”。
