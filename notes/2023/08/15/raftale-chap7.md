可串行化快照隔离
2PL牺牲性能，获取了可串行化的强隔离级别，解决了弱隔离等级容易出现的各种竞争条件（lost update、write skew and phantoms）。
但另一种 可串行化快照隔离（SSI, serializable snapshot isolation）的算法 可以牺牲更少的性能，实现2PL实现的可串行化。
SSI现在是PostgreSQL的可串行化隔离级别，也用于分布式数据库FoundationDB。


悲观与乐观的并发控制
悲观并发控制（pessimistic）：总是假设最坏的情况会发生，所以尽可能保证安全后（加互斥锁）再执行逻辑。
串行执行可以认为是最悲观的情况，2PL中事务一旦有写入，就会加上一个独占锁，防止其他事务的读写；再拿独占锁时，也是保证了没有其他事务持有任何锁的情况下。
乐观并发控制：乐观的认为不存在太多竞用（contention），先执行，直到最后一刻进行检查是否冲突，如果冲突就中止。
串行化快照隔离就是一种乐观的并发控制，如果存在潜在的危险也继续执行事务，直到事务想要提交时，才检查隔离是否被违反，如果是的话，事务将被中止，并且必须重试。

如果有足够的空闲容量，并且事务之间的竞争不高，乐观比悲观好；
如果确实存在很大的竞争，悲观比乐观好，同时如果系统已经接近最大吞吐量，来自重试事务的额外负载会使性能变差。

SSI顾名思义，基于快照隔离，事务中所有的读取都是来自数据库的一致性快照。在快照隔离的基础上，SSI添加了一种算法来检测写入之间的串行化冲突，并确定中止哪些事务。

基于过时前提的决策
并发中竞态条件就是 基于可能失效的读取来决定了下一次的写入。快照隔离中之所以会有丢失更新、写入偏差和幻读，也是基于并发的事务之间 一个事务的读取被另一个事务的写入变得失效，导致接下来的写入不满足某种数据一致性约束，换句话说，事务基于一个前提来决策，基于一个过时的前提就可能造成有害的结果。
在乐观锁的背景下，如果数据库能够检查到这种过时的情况，中止事务，就不会产生竞态条件引起的并发问题。
所以问题是：数据库如何知道一个事务中的查询结果是否可能已经发生了改变？有两种情况需要考虑：
1. 检测对旧MVCC对象版本的读取（读之前存在未提交的写入）
  a. 事务A写O1，写O2
  b. 事务B读O1，写O3，O1失效
  c. 2PL中事务写O1时拿的独占锁，释放后事务B才能读O1
2. 检测影响先前读取的写入（读之后发生写入）
  a. 

检测旧MVCC读取
读之前存在未提交的写入
快照隔离中，读取时写入的快照对读取事务不可见（防止脏读）。
基于此，如果读取快照之前存在未提交的写入，一旦写入提交后读取结果将会失效（同一事务读取后有写入）。
为了防止这个异常，数据库需要跟踪一个事务由于MVCC可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有被忽略的写入现在已经提交，一旦提交，事务将中止。
当检测到陈旧的读取后，为什么不立即中止事务，因为如果后面没有写的话，就不需要中止，没有写入偏差的风险。
1. 如果后续没有写入，那自然没有写入偏差的风险，不需要中止
2. 未提交的写入可能中止或者仍未提交，那读取还是没有过时，后续写入也不会有问题。
乐观的通过不必要的中止，SSI保留了快照隔离从一致快照中长时间读取的能力
检查影响先前读取的写入
另外一种情况是读之后发生写入，写入提交之后明显会导致读的数据过时。

两阶段锁定中，为了避免幻读，给查询的搜索条件加上了锁，也就是谓词锁，然后有近似谓词锁的条件范围锁。条件范围锁分为共享锁和独占锁，保证读写的相互阻塞。
SSI可以利用条件范围锁，但他是一种比2PL更乐观的方式，索引上任何一个范围有被读取都会做记录，事务42写锁的获取并不会等待读锁的释放，直接获取写锁后，提交时再通过事务43已经更改了数据。如果事务43想提交写入时，就会被中止然后重试。
可以很明显看到乐观锁的身影，即使后来的写入影响了先前的读，也不立即中止，因为有可能后续也是读，在有写的条件下才进行中止。
可串行化快照隔离的性能
2PL是悲观的假设读写一定会产生竞态条件，所以读写相互阻塞，但大多数时候，事务读取被另一个事务覆盖的信息不会产生并发问题，SSI使用这个理论减少不必要的中止。
与2PL相比，SSI最大的优点是一个事务不需要阻塞等待另一个事务的锁，它利用了快照隔离的优势，写不会阻塞读，同时也超越了弱的隔离级别，使得读也不会阻塞写（2PL就会加共享锁）。读也不需要持有锁，而是采用了消息通知的方式，来中止可能的冲突。
相比于串行执行，不局限于单个CPU核的吞吐量。
SSI要求读写的事务尽可能短：长时间的读取写入数据导致中止的概率增加 ；
