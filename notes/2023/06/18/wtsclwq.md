  ### 完全解决复制延迟问题

虽然很多问题可以在应用层解决，比如上面的三个问题，都可以通过限制客户端的读写行为解决，但是这会大大增加应用层代码的复杂度。

我们做数据系统，应该最大程度为应用层提供便利性。

因此事务在分布式系统中又被提起了，很多NoSQL数据库起初都放弃了事务，最后又捡起来。

不过分布式系统中的事务自然也是**分布式事务**

## 多主模型

单主模型很容易带来写入瓶颈问题，因为所有的写入操作都要由Leader完成。

自然而然有人会去研究多主模型。

> 有多个可以接受写入的主副本，每个主副本在接收到写入之后，都要转给所有其他副本。即一个系统，有多个**写入点**。

### 多主模型的应用场景

#### 多数据中心

![img](https://wtsclwq.oss-cn-beijing.aliyuncs.com/fig5-6.png)

因为对于多数据中心的单主模型来说，复制到其他数据中心的成本太高了，但是对于多主模型来说，每个数据中心有一个Leader，可以先在自己的数据中心复制，然后Leader之间再解决冲突。

该场景下，单主和多主的对比：

| 对比项 | 单主模型                                   | 多主模型                             |
| ------ | ------------------------------------------ | ------------------------------------ |
| 性能   | 所有写入都要路由到一个数据中心             | 写入可以就近                         |
| 可用性 | 主副本所在数据中心故障，需要有个切主的过程 | 每个数据中心可以独立工作             |
| 网络   | 跨数据中心，写入对网络抖动更敏感           | 数据中心间异步复制，对公网容错性更高 |

当然，看起来很方便，但是**实践起来很复杂**。

#### 离线工作的客户端

有这样一种应用场景：虽然我手机上日历和便签可以离线工作，我可以随时在上面增加新的日程和笔记，而且在下一次联网的时候就会同步到远程服务器。

如果我有多设备：手机1、手机2、笔记本，那么上述的工作模式就可以将它们都看作是一个Leader，因为他们接受写入请求。并且这是一个多主模型。

但是这种场景对于复制延迟的要求很低，可能几个小时甚至几个月。但是却很容易发生冲突，因此复杂度也很高。

> 从架构的角度来看，这种设置实际上与数据中心之间的多主复制类似，每个设备都是一个 “数据中心”，而它们之间的网络连接是极度不可靠的
