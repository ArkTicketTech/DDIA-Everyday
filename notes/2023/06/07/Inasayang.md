多主节点复制

-   处理写的每个主节点都会将数据更改转发到所有其他节点
-   每个主节点也是其他主节点的从节点
-   同一个DC下，使用多主节点没有太大意义
-   多DC下，副本横跨多个DC，更接近用户和容忍故障
-   每个DC下，使用单主复制，DC直接，由各个主节点负责交换数据（异步复制）
-   多主复制的问题，不同DC修改相同的数据，如何解决冲突？
-   自增注解，触发器，完整性约束？



离线客户端操作

-   应用断开网络后继续工作
-   设备需要充当主节点的本地数据库（接受写请求）,所有设备之前异步同步多主节点的副本（同步滞后时间取决于设备再次联网时间）
-   同一个局域网下的多个设备呢，局域网下同步？待定



协作编辑

-   不完全等价于数据库复制
-   一个用户所作的更改会立即应用到本地副本，再异步复制到复制器和同一文档的其他用户
-   一种不好的方案：先将文档锁定，如果要多人同时编辑，需要先等待锁释放（类似于主从复制下的主节点执行事务操作）



处理写冲突

-   两个主节点同时修改同一条记录导致写冲突
-   同步与异步冲突检测
    -   避免冲突，应用层保证对特定记录的写请求总是同一个主节点
        -   如，用户更新自己的数据，保证请求总是路由到特定的DC，不同的用户对应不同的DC（等价于主从复制）
        -   问题：DC发生故障；用户漫游到另一个地理位置（避免冲突不再有效）
    -   收敛于一致状态
        -   所有复制模型至少确保所有副本的最终一致状态是一致的，以收敛趋同的方式解决冲突
        -   方案
            -   每个写入都携带一个唯一的ID（时间戳（很容易造成数据丢失，不懂啊），随机数（这能用随机？），UUID（？怎么判断），基于键值的哈希（没懂）），挑选最高的ID写入为最终结果
            -   为每个副本分配一个唯一的ID，并指定规则（序号的高的优先，会丢失数据！不懂啊）
            -   以某种方式合并这些值
            -   利用预定好的格式记录保留冲突的相关信息，依靠应用层的逻辑，事后解决冲突（提示用户，git那种？）
    -   自定义冲突解决逻辑
        -   解决冲突的最合适方式还得是应用层
        -   写入时执行
            -   复制变更时检测到冲突，调用冲突处理程序
        -   读取时执行
            -   检测冲突，所有冲突写入值都会暂时保存下来。下次读取，会把数据的多个版本返回给应用层。提示用户或自动解决冲突，最后结果返回到数据库
        -   通常用于当个行或文档，不是整个事务（一个原子事务包含多个不同写请求）



自动冲突解决

-   无冲突的复制数据类型（`Conflict-free Replicated Datatypes，CRDT`）
    -   多个用户同时编辑的数据结构，包括`map`，`ordered list`，计数器等，以内置的合理方式自动解决冲突
    -   双向合并
-   可合并的持久数据结构（`Mergeable persistent data`）
    -   跟踪变更历史（git）
    -   三向合并
-   操作转换（`Operational transformation`）
    -   `Google doc`采用的冲突解决算法
    -   为可同时编辑的有序列表而设计



Pp. 160-166