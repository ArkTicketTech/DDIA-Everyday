### 容错



#### 微批量与存档点

流出错的一个解决方案是将流分成小块，并像微型批处理一样处理每个块。这个方法被称为microbatching，它被用于spark streaming。

Flink则使用了另一个钟不同的方法，它会定期生成状态的滚动存档点并将其写入持久存储。如果流算子崩溃，它可以从最近的存档点重启，并丢弃从最近检查点到崩溃之间的所有输出。存档点会由消息流中的barrier触发，类似于microbatching之间的边界，但不会强制一个特定的窗口大小。

在流处理框架的范围内，microbatching和存档点方法都提供了与批处理一样的恰好一次语义（exactly-once semantics）。但是只要输出离开流处理器（例如，写入数据库，向外部消息代理发送消息，或发送电子邮件），框架就无法抛弃失败批次的输出了。这种情况下，重启失败任务会导致外部副作用发生两次，只有微批次和存档点不足以阻止这一问题。



#### 原子提交再现

为了在出现故障时表现出恰好处理一次的样子，我们需要确保事件处理的所有输出和副作用 当且仅当处理成功时才会生效。





#### 幂等性

能安全的重试的要求是 保持任务的幂等性。

即使一个操作不是天生幂等的，往往可以通过一些额外的元数据做成幂等的。例如，在使用来自kafka的消息时，每条消息都有一个持久的、单调递增的偏移量。将值写入外部数据库时可以带上这个偏移量，这样你就可以判断一条更新是不是已经执行过了，避免重复执行。

Storm的Trident基于类似的想法来处理状态。



#### 失败后重建状态

任何需要状态的流处理，例如，任何窗口聚合以及任何用于连接的表和索引，都必须确保在失败之后能恢复其状态。

一种选择是将状态保存在远程数据存储中，并进行复制。

另一种方法是在流处理器本地保存状态，并定期复制。



Flink定期捕获算子状态的快照，并将它们写入HDFS等持久性存储中。Kafka通过将状态变更发送到具有日志压缩功能的专用kafak主题来复制状态变更。



另一种选择是不需要复制状态，而是从输入流进行重建。



### 本章小结

流处理类似于批处理，但流处理是在无限的流而不是固定大小的输入上持续进行。从这个角度来看，消息代理和事件日志可以视作文件系统的流式等价物。

两种消息代理的方式：

1. AMQP/JMS风格的消息代理：消息被消费者确认后从代理中删除；
2. 基于日志的消息代理：

1. 1. 代理将一个分区中的所有消息分配给同一个消费者节点，并始终以相同的顺序传递消息。
2. 并行是通过分区实现的，消费者通过存档最近处理消息的偏移量来跟踪工作进度。
3. 消息代理将消息保留在磁盘上，因此如果有必要的话，可以回跳并重新读取旧消息。

将数据库的写入视作流也是很有用的，我们可以捕获变更日志。即对数据库所做的所有变更的历史记录，隐式地通过变更数据捕获，或显式地通过事件溯源。
