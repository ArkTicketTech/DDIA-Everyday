导致进程暂停的时间：
* GC 在运行期间暂停所有线程。
* 虚拟化环境中暂停虚拟机（暂停所有执行进程并将内存状态保存到磁  
盘）然后继续（从内存中加载数据然后继续执行）
* 用户在自己的设备上主动休眠。
* 操作系统执行线程上下文切换时，或者虚拟机程序切换到另一个虚拟机时，正在运行的线程可能会在代码运行的任意位置被暂停。
* 如果应用程序执行同步磁盘操作， 则线程可能暂停并等待磁盘 IO 完成。例如 Java 类加载器在第一次使用类文件时会推迟加载，这可能导致在程序的任意执行时刻发生暂停。
* 如果操作系统发生了基于磁盘的内存交换分区，内存访问可能出发缺页中断，继而需要从磁盘中加载内存页，在进行 IO 时导致线程暂停。如果内存使用压力大，会导致更多页面换出到磁盘，极端情况下，会花费大量时间在页面换入换出上，但实际完成工作很少。为了避免该问题，通常在服务器上禁用分页。
* 通过发送 SIGSTOP 信号来暂停 UNIX 进程， 例如在shell中按下Ctrl-Z。 这个信号会立即停止进程避免其拿到更多的CPU周期， 直到接下来收到信号SIGCONT之后才从停止的地方继续运行。

以上场景中，线程自身并不能知道自己被暂停执行了，切换上下文和并行性可能随时发生。

分布式系统中的一个节点必须假定， 执行过程中的任何时刻都可能被暂停相当长一段时间， 包括运行在某个函数中间。 暂停期间， 整个集群的其他部分都在照常运行， 甚至会一致将暂停的节点宣告为故障节点。 最终， 暂停的节点可能会回来继续运行， 除非再次检查时钟， 否则它对刚刚过去的暂停毫无意识。

##### Response time guarantees
某些软件（例如飞机，火箭）等系统，必须给其设定一个响应上限，如果无法满足，则导致系统故障，这类系统被称之为硬实时系统。

提供实时保证需要来自软件栈的多个层面的支持：
* 实时操作系统，保证在给定的间隔内完成 CPU 时间片的调度分配
* 库函数必须考虑最坏的执行时间
* 动态内存分配受限或者完全被禁止
* 大量充分的测试和验证
* 限制了编程语言



##### Limiting the impact of garbage collection
语言绑定的垃圾回收机制可以跟踪对象的分配情况以及剩余的空闲内存， 因而可以在运行时灵活控制垃圾回收。

想法：
* 把 GC 暂停视为节点的一个计划内的临时离线， 当节点启动垃圾回收时， 通知其他节点来接管客户端的请求。
* 系统可以提前为前端应用发出预警， 应用会等待当前请求完成， 但停止向该节点发送新的请求， 这 样垃圾回收可以在无干扰的情况下更加高效运行。
* 只对短期对象（可以快速回收）执行垃圾回收， 然后在其变成长期存活对象之前， 采取定期重启的策略从而避免对长期存活对象执行全面回收。每次选择一个节点重新启动， 在重启之前， 重新平衡节点之间的流量， 思路与滚动升级类似。