### 事件溯源

Event Sourcing是数据持久化的一种方式，对数据只做新增，不做修改和删除。在一些数据变更非常重要的业务场景，如财务、金融领域，可能会使用这种数据持久化方式。事件溯源在流处理中也比较有用。

与变更数据捕获类似，事件溯源涉及到将「所有对应用状态的变更」存储为变更事件日志。最大的区别是事件溯源将这一想法应用到了一个不同的抽象层次上：

1. 在变更数据捕获中，应用以可变方式使用数据库，可以任意更新和删除记录。变更日志是从数据库的底层提取的，从而确保从数据库提取的写入顺序与实际写入的顺序相匹配，从而避免多数据库源下的竞态条件。写入数据的应用不需要知道CDC的存在；
2. 在事件溯源中，应用层的新增、删除、更新是构建在写入只能追加的场景下（基于日志）。在这种情况下，事件存储是仅追加写入的， 更新和删除是禁止的。



事件溯源是一种强大的数据建模技术，从应用的角度来看，将用户的行为记录为不可变的事件更有意义，而不是在可变数据库中记录这些行为的影响。事件溯源使得应用随事件演化更为容易，通过更容易的理解事情发生的原因来帮助调试的进行，并有利于防止应用bug。



基于事件溯源的产品：Event Store



#### 从事件日志中派生出当前状态

使用事件溯源的应用读取时需要读取所有日志进行重放。

与CDC一样，重播事件日志允许让你重新构建系统的当前状态。不过，日志压缩在事件溯源这里是不可行的，因为本身就是需要完整的历史事件，而CDC事件通常包含的是记录的完整新版本。



#### 命令和事件

事件溯源的哲学是仔细区分事件（event）和命令（command）。当来自用户的请求刚刚到达时，它一开始是个命令，在这个时间点它仍然可能失败，比如它违反了一些约束条件（如唯一性等）。应用必须首先验证它是否可以执行该命令，如果验证成功并且命令被接受，则它变为一个持久化且不可变的事件。

例如，用户试图注册特定用户名、预定飞机或剧院的座位，则应用需要检查用户名或者座位是否已经被占用。当检查成功后，应用可以生成一个事件，指示特定的用户名是由特定的用户ID注册的，或者座位已经预留给特定的顾客。

在事件生成的时刻，它就成为了事实（ƒact）。即使客户稍后决定更改或者取消预订，他们之前曾预订了某个特定座位的事实仍然成立，而更改或取消是之后添加的单独的事件。

事件流的消费者不允许拒绝事件：当消费者看到事件时，它已经成为日志中不可变的一部份，并且可能已经被其他消费者看到了。因此任何对命令的验证，都需要在它称为事件之前同步完成。例如，通过使用一个可以原子性地自动验证命令并发布事件的可串行事务。

或者，预订座位的用户请求可以拆分为两个事件：第一个是暂时预约，第二个是验证预约后的独立的确认事件。这种分割方式允许验证发生在一个异步的过程中。



### 状态、流和不变性

我们通常将数据库视为应用程序当前状态的存储，这种表示针对读取进行了优化，而且通常对于服务查询是最为方便的表示。状态的本质是：它会变化，所以数据库才会支持数据的增删改。

只要你的状态发生了变化，那么这个状态就是这段时间中事件修改的结果。无论状态如何变化，总有一系列事件导致了这些变化。即使事情已经执行和回滚，这些事件出现是始终成立的。

如果你持久存储了变更日志，那么重现状态就非常简单。

日志压缩是连接日志和数据库状态之间的桥梁：日志压缩后只保留每条记录的最新版本，并丢弃被覆盖的版本。



#### 不可变事件的优点

会计：可审计性。

如果你意外的部署了将错误数据写入数据库的错误代码，当代码会破坏性地覆写数据时，恢复要困难的多。使用不可变事件的仅追加日志，诊断问题与故障恢复就要容易的多。

不可变的事件包含了比当前状态更多的信息。这些信息可以用来商业分析或者流程分析。
