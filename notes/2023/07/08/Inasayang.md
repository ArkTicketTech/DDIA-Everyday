分布式事务与共识

-   共识的不可能性
    -   FLP结论：如果节点存在可能崩溃的风险，则不存在总是能够达成共识的稳定算法
        -   基于异步系统模型做出的证明



原子提交与两阶段提交

从单节点到分布式的原子提交

-   单个数据库节点上，原子性有存储引擎负责
-   一个事务设计多个节点
    -   向所有节点发送一个提交请求，各个节点再独立执行是不够的
        -   某些节点检测到位反约束或冲突导致中止
        -   某些请求可能由于网络导致超时或者丢失
        -   某些节点写日志前发生崩溃
-   补偿性事务：已提交的事务可以被新的事务抵消（需要应用层负责？）



两阶段提交（`two-phase commit，2PC`）

-   多节点间实现事务原子提交，保证所有节点要么全部提交，要么全部中止
-   2PC事务从应用程序在多个数据库节点执行读写开始
    -   准备提交事务时，协调者开始阶段1
        -   发送一个准备请求到所有节点，询问是否可以提交
        -   如果全部都是“是”，则阶段2发出提交请求，开始实际执行
        -   如果有“否”，则阶段2向所有节点发送放弃请求
-   系统的承诺
    -   应用程序启动一个分布式事务，向协调者请求事务ID（全局唯一）
    -   应用层序在每个节点上执行单节点事务，附加全局唯一事务ID到事务上
        -   读写均在单节点上完成
        -   如果出现问题，则协调者和其他参与者都可以安全中止
    -   应用程序准备提交，协调者向所有节点发送准备请求（附带全局事务ID）
        -   如果有一个发生失败，则通知所有节点放弃事务
    -   节点收到准备请求，确保可以提交事务（安全地将事务数据写入磁盘）
    -   协调者收到答复并作出决定
        -   只有所有节点都赞成才会提交
        -   协调者把最后地决定写入到事务日志中，防止系统崩溃，可以恢复（提交点）
    -   协调者决定写入磁盘后，向所有节点发送提交或放弃请求
        -   如果此时出现失败或超时，则协调者必须一致重试，知道成功
        -   如果有节点出现故障，恢复后，也必须继续执行
-   协调者发生故障
    -   阶段1发生失败或超时，协调者会中止事务
    -   阶段2发生失败或超时，协调者会无限期重试(...)
    -   如果协调者在阶段1之后，阶段2之前发生崩溃，节点会无限期等待
        -   理论上，节点间可以互相通信，了解结果并达成一致，但不是2PC的范畴(raft,paxos)



三阶段提交（不常用）

-   2PC也称为阻塞式原子提交协议
-   3PC假定一个有界的网络延迟和节点在规定时间内响应



Pp. 330-337